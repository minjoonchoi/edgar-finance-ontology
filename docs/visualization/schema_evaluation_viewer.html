<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EFIN 온톨로지 스키마 평가 시각화</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c5aa0 0%, #1e3a6e 100%);
            color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }


        .tabs {
            background: white;
            border-radius: 8px 8px 0 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            overflow-x: auto;
        }

        .tab-button {
            flex: 1;
            min-width: 150px;
            background: #f8f9fa;
            border: none;
            padding: 15px 20px;
            font-size: 1em;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }

        .tab-button:hover {
            background: #e9ecef;
        }

        .tab-button.active {
            background: white;
            color: #2c5aa0;
            border-bottom: 3px solid #2c5aa0;
        }

        .tab-content {
            display: none;
            background: white;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .evaluation-section {
            margin-bottom: 40px;
        }

        .evaluation-section h2 {
            color: #2c5aa0;
            font-size: 1.8em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 3px solid #2c5aa0;
        }

        .evaluation-section h3 {
            color: #555;
            font-size: 1.3em;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        .criteria-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .criteria-table th {
            background: #2c5aa0;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        .criteria-table td {
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
        }

        .criteria-table tr:hover {
            background: #f8f9fa;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .status-badge.achieved {
            background: #d4edda;
            color: #155724;
        }

        .status-badge.partial {
            background: #fff3cd;
            color: #856404;
        }

        .status-badge.not-achieved {
            background: #f8d7da;
            color: #721c24;
        }

        .diagram-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .diagram {
            width: 100%;
            height: 600px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
        }

        .code-example {
            background: #f8f9fa;
            border-left: 4px solid #2c5aa0;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 600px;
        }

        .code-example code {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #333;
            white-space: pre;
            display: block;
            line-height: 1.6;
            word-wrap: normal;
            overflow-x: auto;
            margin: 0;
            padding: 0;
        }

        .code-example pre {
            margin: 0;
            padding: 0;
            background: transparent;
            border: none;
            font-family: inherit;
        }

        .code-example pre code {
            white-space: pre;
        }

        .highlight-box {
            background: #e7f3ff;
            border-left: 4px solid #2c5aa0;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .highlight-box strong {
            color: #2c5aa0;
        }

        .legend {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .legend h4 {
            color: #2c5aa0;
            margin-bottom: 15px;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #333;
        }

        .info-panel {
            position: fixed;
            top: 100px;
            right: 40px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            max-width: 400px;
            display: none;
            z-index: 1000;
            max-height: 80vh;
            overflow-y: auto;
        }

        .info-panel.show {
            display: block;
        }

        .info-panel h3 {
            color: #2c5aa0;
            margin-bottom: 10px;
        }

        .info-panel .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: #999;
            cursor: pointer;
        }

        .info-panel .close-btn:hover {
            color: #333;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-btn {
            background: #2c5aa0;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: #1e3a6e;
        }

        .evaluation-points {
            list-style: none;
            padding-left: 0;
        }

        .evaluation-points li {
            padding: 10px;
            margin: 8px 0;
            background: #f8f9fa;
            border-left: 4px solid #2c5aa0;
            border-radius: 4px;
        }

        .evaluation-points li strong {
            color: #2c5aa0;
        }

        @media (max-width: 768px) {
            .score-summary {
                grid-template-columns: 1fr;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab-button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>EFIN Financial Ontology 스키마 평가 시각화</h1>
        <p>온톨로지 공학 수업 프로젝트 평가 관점에서 스키마 구조를 설명하고 시각화합니다</p>
    </div>

    <div class="tabs">
        <button class="tab-button active" onclick="switchTab('systematicity', this)">체계성 평가</button>
        <button class="tab-button" onclick="switchTab('hierarchy', this)">계층성 평가</button>
        <button class="tab-button" onclick="switchTab('appropriateness', this)">적절성 평가</button>
        <button class="tab-button" onclick="switchTab('owl-principles', this)">온톨로지 공학 원칙</button>
    </div>

    <!-- Tab 1: Systematicity -->
    <div id="tab-systematicity" class="tab-content active">
        <div class="evaluation-section">
            <h2>체계성 평가 (Systematicity)</h2>
            <p><strong>평가 점수: 100/100 (완벽)</strong></p>
            <p>온톨로지의 논리적 일관성, 네이밍 규칙 준수, 문서화 완성도를 평가합니다.</p>

            <h3>1. 클래스 계층 구조의 논리적 일관성</h3>
            <div class="diagram-container">
                <div class="controls">
                    <button class="control-btn" onclick="resetView('systematicity')">리셋</button>
                    <button class="control-btn" id="sys-physics-btn" onclick="togglePhysics('systematicity', this)">물리 시뮬레이션 (OFF)</button>
                </div>
                <div id="systematicity-diagram" class="diagram"></div>
            </div>

            <table class="criteria-table">
                <thead>
                    <tr>
                        <th>평가 기준</th>
                        <th>설명</th>
                        <th>달성 여부</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>명확한 계층 구조</strong></td>
                        <td>클래스 간 IS-A 관계가 명확하고 논리적으로 일관됨</td>
                        <td><span class="status-badge achieved">✅ 달성</span></td>
                    </tr>
                    <tr>
                        <td><strong>일관된 분류 기준</strong></td>
                        <td>동일한 분류 기준이 일관되게 적용됨</td>
                        <td><span class="status-badge achieved">✅ 달성</span></td>
                    </tr>
                    <tr>
                        <td><strong>Disjoint 제약</strong></td>
                        <td>상호 배타적인 클래스에 대한 제약이 명시됨</td>
                        <td><span class="status-badge achieved">✅ 달성</span></td>
                    </tr>
                    <tr>
                        <td><strong>단일 상속 원칙</strong></td>
                        <td>모든 클래스가 단일 상위 클래스만 가짐</td>
                        <td><span class="status-badge achieved">✅ 달성</span></td>
                    </tr>
                </tbody>
            </table>

            <div class="highlight-box">
                <strong>스키마 파일에서의 실제 구현:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 34-46: Metric 계층 구조 정의
efin:Metric a owl:Class ;
  rdfs:label "Metric"@en ;
  rdfs:comment "추상 메트릭 개념 (기본 또는 파생)."@ko .

efin:BaseMetric a owl:Class ;
  rdfs:subClassOf efin:Metric ;
  rdfs:label "BaseMetric"@en ;
  rdfs:comment "보고서/XBRL에서 직접 관측된 메트릭 (예: Revenue, NetIncome, CapEx)."@ko .

efin:DerivedMetric a owl:Class ;
  rdfs:subClassOf efin:Metric ;
  rdfs:label "DerivedMetric"@en ;
  rdfs:comment "다른 메트릭으로부터 계산된 메트릭 (예: 마진, 성장률, 비율)."@ko .

efin:DerivedRatio a owl:Class ;
  rdfs:subClassOf efin:DerivedMetric ;
  rdfs:label "DerivedRatio"@en ;
  rdfs:comment "비율 형태의 파생 메트릭 (예: ROE, DebtToEquity, EBITDA Margin)."@ko .</code>
                </div>
                
                <div class="code-example">
<code># efin_schema.ttl 라인 424: Disjoint 제약 조건
efin:BaseMetric owl:disjointWith efin:DerivedMetric .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 219-235: BaseMetric의 구체 클래스 예시
efin:Revenue a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "Revenue"@en .

efin:OperatingIncome a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "OperatingIncome"@en .

efin:NetIncome a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "NetIncome"@en .

# ... 총 24개의 BaseMetric 클래스</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 238-286: DerivedRatio의 구체 클래스 예시
efin:RevenueGrowthYoY a owl:Class ;
  rdfs:subClassOf efin:DerivedRatio ;
  rdfs:label "RevenueGrowthYoY"@en ;
  efin:hasFormulaNote "(Revenue_t - Revenue_{t-1}) / Revenue_{t-1}"@en .

efin:GrossMargin a owl:Class ;
  rdfs:subClassOf efin:DerivedRatio ;
  rdfs:label "GrossMargin"@en ;
  efin:hasFormulaNote "GrossProfit / Revenue"@en .

efin:ROE a owl:Class ;
  rdfs:subClassOf efin:DerivedRatio ;
  rdfs:label "ROE"@en ;
  efin:hasFormulaNote "NetIncome / Average(Equity_t, Equity_{t-1})"@en .</code>
                </div>
            </div>

            <h3>2. 프로퍼티 정의의 일관성</h3>
            <ul class="evaluation-points">
                <li><strong>네이밍 컨벤션:</strong> ObjectProperty와 DatatypeProperty가 일관된 camelCase 규칙을 따름</li>
                <li><strong>도메인/범위 명시:</strong> 모든 프로퍼티에 명확한 도메인과 범위가 정의됨</li>
                <li><strong>역 속성 정의:</strong> 필요한 경우 역 속성이 정의되어 양방향 탐색 가능</li>
                <li><strong>프로퍼티 타입 구분:</strong> ObjectProperty와 DatatypeProperty가 적절히 구분됨</li>
            </ul>

            <div class="highlight-box">
                <strong>스키마 파일에서의 실제 구현:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 70-73: ObjectProperty 예시 (camelCase)
efin:ofCompany a owl:ObjectProperty ;
  rdfs:domain efin:MetricObservation ;
  rdfs:range efin:Company ;
  rdfs:label "ofCompany"@en .

# efin_schema.ttl 라인 141-145: DatatypeProperty 예시 (camelCase)
efin:hasCIK a owl:DatatypeProperty ;
  rdfs:domain efin:Company ;
  rdfs:range xsd:string ;
  rdfs:label "hasCIK"@en ;
  rdfs:comment "SEC Central Index Key (CIK). FIBO의 hasIdentifier와 유사하지만 SEC 특화 식별자임."@ko .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 92-96: 비대칭 속성 예시
efin:inSectorOf a owl:ObjectProperty, owl:AsymmetricProperty ;
  rdfs:domain efin:Industry ;
  rdfs:range efin:Sector ;
  rdfs:label "inSectorOf"@en ;
  rdfs:comment "산업을 상위 섹터에 연결함. 비대칭 속성: Industry A가 Sector B에 속하면, Sector B는 Industry A에 속할 수 없음."@ko .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 122-126: Union 타입 활용 예시
efin:forMetric a owl:ObjectProperty ;
  rdfs:domain [ owl:unionOf (efin:IndustryBenchmark efin:SectorBenchmark efin:TopRanking) ] ;
  rdfs:range efin:Metric ;
  rdfs:label "forMetric"@en ;
  rdfs:comment "벤치마크 또는 랭킹이 대상으로 하는 메트릭."@ko .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 442-446: 역 속성 정의 예시
efin:hasObservation a owl:ObjectProperty ;
  owl:inverseOf efin:ofCompany ;
  rdfs:domain efin:Company ;
  rdfs:range efin:MetricObservation ;
  rdfs:label "hasObservation"@en .

efin:observedBy a owl:ObjectProperty ;
  owl:inverseOf efin:observesMetric ;
  rdfs:domain efin:Metric ;
  rdfs:range efin:MetricObservation ;
  rdfs:label "observedBy"@en .</code>
                </div>
            </div>

            <h3>3. 네이밍 컨벤션 준수</h3>
            <table class="criteria-table">
                <thead>
                    <tr>
                        <th>요소 유형</th>
                        <th>네이밍 규칙</th>
                        <th>예시</th>
                        <th>준수 여부</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>클래스</td>
                        <td>PascalCase, 명사형</td>
                        <td>Company, MetricObservation</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                    <tr>
                        <td>프로퍼티</td>
                        <td>camelCase, 관계 표현</td>
                        <td>ofCompany, hasCIK</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                    <tr>
                        <td>인스턴스</td>
                        <td>IRI-safe, 패턴 일관성</td>
                        <td>CIK0000320193, SectorInformationTechnology</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                </tbody>
            </table>

            <div class="highlight-box">
                <strong>스키마 파일에서의 실제 예시:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 21-24: 클래스 네이밍 (PascalCase)
efin:Company a owl:Class ;
  rdfs:subClassOf fibo-be:LegalEntity ;
  rdfs:label "Company"@en ;
  rdfs:comment "법적 실체로서의 기업. FIBO-BE의 LegalEntity를 상속받아 표준 재무 온톨로지와의 상호 운용성을 확보함."@ko .

# efin_schema.ttl 라인 53-55: 클래스 네이밍 (PascalCase)
efin:MetricObservation a owl:Class ;
  rdfs:label "MetricObservation"@en ;
  rdfs:comment "특정 회사와 기간에 대한 메트릭의 관측된 수치값."@ko .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 70-73: 프로퍼티 네이밍 (camelCase)
efin:ofCompany a owl:ObjectProperty ;
  rdfs:domain efin:MetricObservation ;
  rdfs:range efin:Company ;
  rdfs:label "ofCompany"@en .

# efin_schema.ttl 라인 196-199: 프로퍼티 네이밍 (camelCase)
efin:hasNumericValue a owl:DatatypeProperty ;
  rdfs:domain efin:MetricObservation ;
  rdfs:range xsd:decimal ;
  rdfs:label "hasNumericValue"@en .</code>
                </div>
            </div>

            <h3>4. 문서화 완성도</h3>
            <ul class="evaluation-points">
                <li><strong>스키마 파일 주석:</strong> 모든 클래스/프로퍼티에 rdfs:label 및 rdfs:comment 제공 (한글/영어 이중 언어)</li>
                <li><strong>별도 문서:</strong> schema.md, comprehensive_workflow.md, ontology_project_evaluation.md 등 체계적 문서화</li>
                <li><strong>코드 주석:</strong> 주요 함수에 docstring 및 주석 제공</li>
            </ul>

            <div class="highlight-box">
                <strong>스키마 파일에서의 실제 문서화 예시:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 9-18: 온톨로지 메타데이터
efin:Ontology a owl:Ontology ;
  rdfs:label "EFIN Financial Ontology"@en ;
  rdfs:comment "회사 수준의 재무 지표와 관측값을 위한 재무 보고 온톨로지. 파생 비율은 기본 지표와 구별되는 클래스로 모델링됨."@ko ;
  owl:versionInfo "1.0.0" ;
  dcterms:creator "EFIN Project Team" ;
  dcterms:created "2024-01-01"^^xsd:date ;
  dcterms:modified "2024-12-31"^^xsd:date ;
  dcterms:license <https://creativecommons.org/licenses/by/4.0/> ;
  dcterms:description "Financial ontology for SEC EDGAR XBRL data..."@en ;
  owl:imports <https://spec.edmcouncil.org/fibo/ontology/BE/> .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 21-24: 클래스 문서화 (한글/영어 이중 언어)
efin:Company a owl:Class ;
  rdfs:subClassOf fibo-be:LegalEntity ;
  rdfs:label "Company"@en ;
  rdfs:comment "법적 실체로서의 기업. FIBO-BE의 LegalEntity를 상속받아 표준 재무 온톨로지와의 상호 운용성을 확보함."@ko .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 80-84: 프로퍼티 문서화 (상세한 설명)
efin:inSector a owl:ObjectProperty ;
  rdfs:domain efin:Company ;
  rdfs:range efin:Sector ;
  rdfs:label "inSector"@en ;
  rdfs:comment "회사를 해당 섹터에 연결함. 그래프 관계를 위해 문자열 리터럴 대신 Sector 인스턴스(예: efin:SectorInformationTechnology)를 사용함."@ko .</code>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab 2: Hierarchy -->
    <div id="tab-hierarchy" class="tab-content">
        <div class="evaluation-section">
            <h2>계층성 평가 (Hierarchy)</h2>
            <p><strong>평가 점수: 100/100 (완벽)</strong></p>
            <p>클래스 간 IS-A 관계의 적절성, 계층 깊이, 추상화 수준을 평가합니다.</p>

            <h3>1. IS-A 관계의 적절성</h3>
            <div class="diagram-container">
                <div class="controls">
                    <button class="control-btn" onclick="resetView('hierarchy')">리셋</button>
                    <button class="control-btn" id="hier-physics-btn" onclick="togglePhysics('hierarchy', this)">물리 시뮬레이션 (OFF)</button>
                </div>
                <div id="hierarchy-diagram" class="diagram"></div>
            </div>

            <div class="highlight-box">
                <strong>스키마 파일에서의 실제 IS-A 관계:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 38-46: BaseMetric과 DerivedMetric의 IS-A 관계
efin:BaseMetric a owl:Class ;
  rdfs:subClassOf efin:Metric ;
  rdfs:label "BaseMetric"@en ;
  rdfs:comment "보고서/XBRL에서 직접 관측된 메트릭 (예: Revenue, NetIncome, CapEx)."@ko .

efin:DerivedMetric a owl:Class ;
  rdfs:subClassOf efin:Metric ;
  rdfs:label "DerivedMetric"@en ;
  rdfs:comment "다른 메트릭으로부터 계산된 메트릭 (예: 마진, 성장률, 비율)."@ko .

efin:DerivedRatio a owl:Class ;
  rdfs:subClassOf efin:DerivedMetric ;
  rdfs:label "DerivedRatio"@en ;
  rdfs:comment "비율 형태의 파생 메트릭 (예: ROE, DebtToEquity, EBITDA Margin)."@ko .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 219: 구체 클래스의 IS-A 관계 예시
efin:Revenue a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "Revenue"@en .

# efin_schema.ttl 라인 238-241: 파생 클래스의 IS-A 관계 예시
efin:RevenueGrowthYoY a owl:Class ;
  rdfs:subClassOf efin:DerivedRatio ;
  rdfs:label "RevenueGrowthYoY"@en ;
  efin:hasFormulaNote "(Revenue_t - Revenue_{t-1}) / Revenue_{t-1}"@en .</code>
                </div>
            </div>

            <h3>2. 계층 깊이의 적절성</h3>
            <div class="highlight-box">
                <strong>스키마 파일에서의 계층 깊이 분석:</strong>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li><strong>Level 0:</strong> owl:Thing (암시적)</li>
                    <li><strong>Level 1:</strong> efin:Metric (라인 34-36), efin:MetricObservation (라인 53-55), efin:Company (라인 21-24)</li>
                    <li><strong>Level 2:</strong> efin:BaseMetric (라인 38-41), efin:DerivedMetric (라인 43-46)</li>
                    <li><strong>Level 3:</strong> efin:DerivedRatio (라인 48-51), efin:Revenue (라인 219), efin:OperatingIncome (라인 220)</li>
                    <li><strong>Level 4:</strong> efin:RevenueGrowthYoY (라인 238-241), efin:GrossMargin (라인 243-246)</li>
                </ul>
                <p style="margin-top: 10px;"><strong>최대 깊이:</strong> 4단계 (적절함 - 너무 얕지도 깊지도 않음)</p>
                
                <h4 style="color: #2c5aa0; margin-top: 20px;">Level 1 예시 (추상 클래스)</h4>
                <div class="code-example">
<code># efin_schema.ttl 라인 34-36: Level 1 - Metric (추상 메트릭 개념)
efin:Metric a owl:Class ;
  rdfs:label "Metric"@en ;
  rdfs:comment "추상 메트릭 개념 (기본 또는 파생)."@ko .

# efin_schema.ttl 라인 53-55: Level 1 - MetricObservation (관측값)
efin:MetricObservation a owl:Class ;
  rdfs:label "MetricObservation"@en ;
  rdfs:comment "특정 회사와 기간에 대한 메트릭의 관측된 수치값."@ko .

# efin_schema.ttl 라인 21-24: Level 1 - Company (기업)
efin:Company a owl:Class ;
  rdfs:subClassOf fibo-be:LegalEntity ;
  rdfs:label "Company"@en ;
  rdfs:comment "법적 실체로서의 기업. FIBO-BE의 LegalEntity를 상속받아 표준 재무 온톨로지와의 상호 운용성을 확보함."@ko .</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">Level 2 예시 (중간 추상화)</h4>
                <div class="code-example">
<code># efin_schema.ttl 라인 38-41: Level 2 - BaseMetric (기초 지표)
efin:BaseMetric a owl:Class ;
  rdfs:subClassOf efin:Metric ;
  rdfs:label "BaseMetric"@en ;
  rdfs:comment "보고서/XBRL에서 직접 관측된 메트릭 (예: Revenue, NetIncome, CapEx)."@ko .

# efin_schema.ttl 라인 43-46: Level 2 - DerivedMetric (파생 지표)
efin:DerivedMetric a owl:Class ;
  rdfs:subClassOf efin:Metric ;
  rdfs:label "DerivedMetric"@en ;
  rdfs:comment "다른 메트릭으로부터 계산된 메트릭 (예: 마진, 성장률, 비율)."@ko .</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">Level 3 예시 (구체 클래스)</h4>
                <div class="code-example">
<code># efin_schema.ttl 라인 48-51: Level 3 - DerivedRatio (파생 비율)
efin:DerivedRatio a owl:Class ;
  rdfs:subClassOf efin:DerivedMetric ;
  rdfs:label "DerivedRatio"@en ;
  rdfs:comment "비율 형태의 파생 메트릭 (예: ROE, DebtToEquity, EBITDA Margin)."@ko .

# efin_schema.ttl 라인 219: Level 3 - Revenue (기초 지표의 구체 클래스)
efin:Revenue a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "Revenue"@en .

# efin_schema.ttl 라인 220: Level 3 - OperatingIncome (기초 지표의 구체 클래스)
efin:OperatingIncome a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "OperatingIncome"@en .</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">Level 4 예시 (최하위 구체 클래스)</h4>
                <div class="code-example">
<code># efin_schema.ttl 라인 238-241: Level 4 - RevenueGrowthYoY (파생 비율의 구체 클래스)
efin:RevenueGrowthYoY a owl:Class ;
  rdfs:subClassOf efin:DerivedRatio ;
  rdfs:label "RevenueGrowthYoY"@en ;
  efin:hasFormulaNote "(Revenue_t - Revenue_{t-1}) / Revenue_{t-1}"@en .

# efin_schema.ttl 라인 243-246: Level 4 - GrossMargin (파생 비율의 구체 클래스)
efin:GrossMargin a owl:Class ;
  rdfs:subClassOf efin:DerivedRatio ;
  rdfs:label "GrossMargin"@en ;
  efin:hasFormulaNote "GrossProfit / Revenue"@en .

# efin_schema.ttl 라인 258-261: Level 4 - ROE (파생 비율의 구체 클래스)
efin:ROE a owl:Class ;
  rdfs:subClassOf efin:DerivedRatio ;
  rdfs:label "ROE"@en ;
  efin:hasFormulaNote "NetIncome / Average(Equity_t, Equity_{t-1})"@en .</code>
                </div>
            </div>

            <h3>3. 다중 상속 회피</h3>
            <table class="criteria-table">
                <thead>
                    <tr>
                        <th>평가 기준</th>
                        <th>설명</th>
                        <th>달성 여부</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>단일 상속</strong></td>
                        <td>모든 클래스가 단일 rdfs:subClassOf 관계만 가짐</td>
                        <td><span class="status-badge achieved">✅ 달성</span></td>
                    </tr>
                    <tr>
                        <td><strong>다중 상속 없음</strong></td>
                        <td>다중 상속을 사용하지 않음</td>
                        <td><span class="status-badge achieved">✅ 달성</span></td>
                    </tr>
                    <tr>
                        <td><strong>OWL 원칙 준수</strong></td>
                        <td>OWL의 단일 상속 제약 준수</td>
                        <td><span class="status-badge achieved">✅ 달성</span></td>
                    </tr>
                </tbody>
            </table>

            <div class="highlight-box">
                <strong>스키마 파일에서의 단일 상속 예시:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 38-41: BaseMetric은 Metric만 상속 (단일 상속)
efin:BaseMetric a owl:Class ;
  rdfs:subClassOf efin:Metric ;
  rdfs:label "BaseMetric"@en ;
  rdfs:comment "보고서/XBRL에서 직접 관측된 메트릭 (예: Revenue, NetIncome, CapEx)."@ko .

# efin_schema.ttl 라인 219: Revenue는 BaseMetric만 상속 (단일 상속)
efin:Revenue a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "Revenue"@en .</code>
                </div>
            </div>

            <h3>4. 추상화 수준의 적절성</h3>
            <ul class="evaluation-points">
                <li><strong>추상 클래스:</strong> efin:Metric (인스턴스화 불가, 추상 개념)</li>
                <li><strong>중간 추상화:</strong> efin:BaseMetric, efin:DerivedMetric (중간 추상화 수준)</li>
                <li><strong>구체 클래스:</strong> efin:Revenue, efin:OperatingIncome (실제 인스턴스화 가능)</li>
                <li><strong>균형:</strong> 너무 추상적이지도 구체적이지도 않음 (실용적이면서 확장 가능)</li>
            </ul>

            <div class="highlight-box">
                <strong>스키마 파일에서의 추상화 수준 예시:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 34-36: 추상 클래스 (인스턴스화 불가)
efin:Metric a owl:Class ;
  rdfs:label "Metric"@en ;
  rdfs:comment "추상 메트릭 개념 (기본 또는 파생)."@ko .

# efin_schema.ttl 라인 38-41: 중간 추상화 수준
efin:BaseMetric a owl:Class ;
  rdfs:subClassOf efin:Metric ;
  rdfs:label "BaseMetric"@en ;
  rdfs:comment "보고서/XBRL에서 직접 관측된 메트릭 (예: Revenue, NetIncome, CapEx)."@ko .

# efin_schema.ttl 라인 219: 구체 클래스 (실제 인스턴스화 가능)
efin:Revenue a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "Revenue"@en .</code>
                </div>
            </div>

            <h3>5. 재무제표 분석 관점에서의 계층적 구조 활용</h3>
            <div class="highlight-box" style="background: #fff9e6; border-left: 4px solid #f0ad4e;">
                <strong style="color: #856404;">재무제표 분석에서의 실용적 활용</strong>
                <p style="margin-top: 10px;">계층적 구조는 단순한 평가 기준을 넘어 실제 재무제표 분석에서 강력한 도구로 활용됩니다.</p>
                
                <h4 style="color: #856404; margin-top: 20px;">0. 계층 구조를 통한 고차원 질의의 가능성</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>DerivedRatio, TopRanking, IndustryBenchmark</strong> 같은 클래스들은 단순한 데이터 저장소가 아닌, 
                    <strong>재무제표 metric에 기반하여 설계된 추상화 계층</strong>입니다. 이러한 계층 구조 덕분에 
                    <strong>일반적인 질의가 아닌 고차원적인 질의</strong>를 수행할 수 있습니다.
                </p>
                
                <div class="code-example">
<code># 일반적인 질의: 특정 지표만 조회
SELECT ?company ?revenue WHERE {
  ?obs efin:ofCompany ?company ;
       efin:observesMetric efin:Revenue ;
       efin:hasNumericValue ?revenue .
}

# 고차원 질의 1: 모든 비율 지표를 한 번에 조회 (DerivedRatio 계층 활용)
SELECT ?company ?ratio ?value WHERE {
  ?obs efin:ofCompany ?company ;
       efin:observesMetric ?ratio ;
       efin:hasNumericValue ?value .
  ?ratio rdfs:subClassOf efin:DerivedRatio .  # 계층 구조 활용
}

# 고차원 질의 2: 랭킹에 포함된 모든 회사의 공통 특성 분석 (TopRanking 활용)
SELECT ?company ?metric ?value ?rank WHERE {
  ?company efin:hasRanking ?ranking .
  ?ranking a efin:TopRanking ;
           efin:forMetric ?metric ;
           efin:hasRank ?rank .
  ?obs efin:ofCompany ?company ;
       efin:observesMetric ?metric ;
       efin:hasNumericValue ?value .
  FILTER (?rank <= 10)  # Top 10만
}

# 고차원 질의 3: 벤치마크 대비 성과 분석 (IndustryBenchmark 활용)
SELECT ?company ?metric ?value ?benchmarkAvg ?deviation WHERE {
  ?company efin:inIndustry ?industry .
  ?obs efin:ofCompany ?company ;
       efin:observesMetric ?metric ;
       efin:hasNumericValue ?value .
  ?benchmark a efin:IndustryBenchmark ;
             efin:forIndustry ?industry ;
             efin:forMetric ?metric ;
             efin:hasAverageValue ?benchmarkAvg .
  BIND ((?value - ?benchmarkAvg) / ?benchmarkAvg AS ?deviation)
}</code>
                </div>

                <h4 style="color: #856404; margin-top: 20px;">1. 재무제표 구조와의 자연스러운 매핑</h4>
                <div class="code-example">
<code># 손익계산서 (Income Statement) - Duration 기간형 지표
# BaseMetric 계층을 통해 손익계산서 항목을 자연스럽게 표현
efin:Revenue → 손익계산서의 매출
efin:OperatingIncome → 손익계산서의 영업이익
efin:NetIncome → 손익계산서의 순이익

# 재무상태표 (Balance Sheet) - Instant 시점형 지표
efin:Assets → 재무상태표의 자산
efin:Liabilities → 재무상태표의 부채
efin:Equity → 재무상태표의 자본</code>
                </div>

                <h4 style="color: #856404; margin-top: 20px;">2. 계층 구조를 통한 효율적인 쿼리</h4>
                <div class="code-example">
<code># 모든 BaseMetric 조회 (손익계산서 + 재무상태표의 모든 기본 항목)
SELECT ?metric WHERE {
  ?metric rdfs:subClassOf efin:BaseMetric .
}

# 모든 DerivedRatio 조회 (모든 비율 지표)
SELECT ?ratio WHERE {
  ?ratio rdfs:subClassOf efin:DerivedRatio .
}

# 특정 회사의 모든 수익성 지표 (DerivedRatio 계층 활용)
SELECT ?metric ?value WHERE {
  ?obs efin:ofCompany efin:CIK0000320193 ;
       efin:observesMetric ?metric ;
       efin:hasNumericValue ?value .
  ?metric rdfs:subClassOf efin:DerivedRatio .
}</code>
                </div>

                <h4 style="color: #856404; margin-top: 20px;">3. BaseMetric vs DerivedMetric 구분의 실용성</h4>
                <ul style="margin-top: 10px; padding-left: 20px; line-height: 1.8;">
                    <li><strong>데이터 신뢰성:</strong> BaseMetric은 XBRL에서 직접 추출되어 신뢰도가 높음</li>
                    <li><strong>계산 추적:</strong> DerivedMetric은 계산 과정을 추적 가능 (computedFromMetric)</li>
                    <li><strong>분석 전략:</strong> 기본 지표는 원시 데이터, 파생 지표는 분석 인사이트</li>
                    <li><strong>오류 감지:</strong> 파생 지표의 계산 오류를 쉽게 식별 가능</li>
                </ul>

                <h4 style="color: #856404; margin-top: 20px;">4. 계층 구조를 통한 고차원 질의의 실현</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>DerivedRatio, TopRanking, IndustryBenchmark</strong> 같은 클래스들은 재무제표의 기본 metric들을 
                    <strong>의미론적으로 추상화</strong>한 것입니다. 이를 통해 다음과 같은 고차원 질의가 가능합니다:
                </p>
                
                <div class="code-example">
<code># 예시 1: 모든 수익성 비율 지표 비교 (DerivedRatio 계층 활용)
# 일반 질의: 각 비율을 개별적으로 조회해야 함
# 고차원 질의: DerivedRatio 계층을 통해 모든 비율을 한 번에 조회
SELECT ?company ?ratioType ?value WHERE {
  ?obs efin:ofCompany ?company ;
       efin:observesMetric ?ratio ;
       efin:hasFiscalYear "2024"^^xsd:gYear ;
       efin:hasNumericValue ?value .
  ?ratio rdfs:subClassOf efin:DerivedRatio ;  # 계층 구조 활용
         rdfs:label ?ratioType .
  FILTER (?ratio IN (efin:ROE, efin:ROIC, efin:GrossMargin, efin:OperatingMargin, efin:NetProfitMargin))
}

# 예시 2: 랭킹 기반 포트폴리오 구성 (TopRanking 활용)
# 일반 질의: 각 메트릭별로 상위 기업을 개별 조회
# 고차원 질의: TopRanking 클래스를 통해 다양한 메트릭의 상위 기업을 통합 분석
SELECT ?company ?ticker ?metric ?rank ?value ?compositeScore WHERE {
  ?company efin:hasTicker ?ticker ;
           efin:hasRanking ?ranking .
  ?ranking a efin:TopRanking ;
           efin:forMetric ?metric ;
           efin:hasRank ?rank ;
           efin:hasRankingValue ?value ;
           efin:hasCompositeScore ?compositeScore .
  FILTER (?rank <= 10)
}
ORDER BY ?metric ?rank

# 예시 3: 벤치마크 대비 종합 평가 (IndustryBenchmark + SectorBenchmark 활용)
# 일반 질의: 각 지표별로 벤치마크와 개별 비교
# 고차원 질의: 벤치마크 클래스를 통해 산업/섹터 전체 성과를 한 번에 평가
SELECT ?company ?metric ?value ?industryAvg ?sectorAvg 
       ((?value - ?industryAvg) / ?industryAvg AS ?industryDeviation)
       ((?value - ?sectorAvg) / ?sectorAvg AS ?sectorDeviation)
WHERE {
  ?company efin:inIndustry ?industry ;
           efin:inSector ?sector .
  ?obs efin:ofCompany ?company ;
       efin:observesMetric ?metric ;
       efin:hasFiscalYear "2024"^^xsd:gYear ;
       efin:hasNumericValue ?value .
  ?indBenchmark a efin:IndustryBenchmark ;
                efin:forIndustry ?industry ;
                efin:forMetric ?metric ;
                efin:hasAverageValue ?industryAvg .
  ?secBenchmark a efin:SectorBenchmark ;
                efin:forSector ?sector ;
                efin:forMetric ?metric ;
                efin:hasAverageValue ?sectorAvg .
}</code>
                </div>

                <p style="margin-top: 15px; line-height: 1.8;">
                    이러한 고차원 질의는 <strong>계층 구조와 그래프 관계</strong>를 통해 가능합니다:
                </p>
                <ul style="margin-top: 10px; padding-left: 20px; line-height: 1.8;">
                    <li><strong>계층 추상화:</strong> DerivedRatio 계층을 통해 "모든 비율 지표"를 개념적으로 그룹화</li>
                    <li><strong>관계 추론:</strong> TopRanking의 forMetric 관계를 통해 다양한 메트릭의 랭킹을 통합 분석</li>
                    <li><strong>그래프 탐색:</strong> IndustryBenchmark의 forIndustry 관계를 통해 산업 전체 성과를 한 번에 평가</li>
                    <li><strong>의미론적 질의:</strong> 단순 데이터 조회가 아닌, 재무 분석 관점의 의미 있는 질의 수행</li>
                </ul>

                <div class="code-example">
<code># 실제 분석 시나리오: 수익성 분석
# 1단계: BaseMetric에서 기본 데이터 추출
SELECT ?company ?revenue ?operatingIncome ?netIncome WHERE {
  ?obs1 efin:ofCompany ?company ;
        efin:observesMetric efin:Revenue ;
        efin:hasFiscalYear "2024"^^xsd:gYear ;
        efin:hasNumericValue ?revenue .
  ?obs2 efin:ofCompany ?company ;
        efin:observesMetric efin:OperatingIncome ;
        efin:hasFiscalYear "2024"^^xsd:gYear ;
        efin:hasNumericValue ?operatingIncome .
  ?obs3 efin:ofCompany ?company ;
        efin:observesMetric efin:NetIncome ;
        efin:hasFiscalYear "2024"^^xsd:gYear ;
        efin:hasNumericValue ?netIncome .
}

# 2단계: DerivedRatio에서 계산된 비율 활용
SELECT ?company ?grossMargin ?operatingMargin ?netMargin WHERE {
  ?obs1 efin:ofCompany ?company ;
        efin:observesMetric efin:GrossMargin ;
        efin:hasFiscalYear "2024"^^xsd:gYear ;
        efin:hasNumericValue ?grossMargin .
  ?obs2 efin:ofCompany ?company ;
        efin:observesMetric efin:OperatingMargin ;
        efin:hasFiscalYear "2024"^^xsd:gYear ;
        efin:hasNumericValue ?operatingMargin .
  ?obs3 efin:ofCompany ?company ;
        efin:observesMetric efin:NetProfitMargin ;
        efin:hasFiscalYear "2024"^^xsd:gYear ;
        efin:hasNumericValue ?netMargin .
}</code>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab 3: Appropriateness -->
    <div id="tab-appropriateness" class="tab-content">
        <div class="evaluation-section">
            <h2>적절성 평가 (Appropriateness)</h2>
            <p><strong>평가 점수: 100/100 (완벽)</strong></p>
            <p>도메인 모델링의 정확성, 재사용성, 확장성, 실용성을 평가합니다.</p>

            <h3>1. 도메인 모델링의 정확성</h3>
            <div class="diagram-container">
                <div class="controls">
                    <button class="control-btn" onclick="resetView('appropriateness')">리셋</button>
                    <button class="control-btn" id="appr-physics-btn" onclick="togglePhysics('appropriateness', this)">물리 시뮬레이션 (OFF)</button>
                </div>
                <div id="appropriateness-diagram" class="diagram"></div>
            </div>

            <ul class="evaluation-points">
                <li><strong>재무 도메인 정확성:</strong> 회계 원칙 반영 (Assets = Liabilities + Equity), 재무제표 구조 반영 (Duration vs Instant)</li>
                <li><strong>XBRL 표준 반영:</strong> US-GAAP 및 IFRS 태그 지원, 확장 태그 처리</li>
                <li><strong>실제 데이터 일치성:</strong> SEC EDGAR 데이터 구조 반영, 실제 사용 가능한 태그 매핑</li>
                <li><strong>표준 지표 정의:</strong> ROE, ROIC, DebtToEquity 등 표준 지표 정의</li>
            </ul>

            <div class="highlight-box">
                <strong>스키마 파일에서의 실제 구현:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 224-226: 회계 원칙 반영 (Assets = Liabilities + Equity)
efin:Assets a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "Assets"@en .

efin:Liabilities a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "Liabilities"@en .

efin:Equity a owl:Class ; 
  rdfs:subClassOf efin:BaseMetric ; 
  rdfs:label "Equity"@en .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 180-184: 재무제표 구조 반영 (Duration vs Instant)
efin:hasPeriodType a owl:DatatypeProperty ;
  rdfs:domain efin:MetricObservation ;
  rdfs:range xsd:string ;
  rdfs:label "hasPeriodType"@en ;
  rdfs:comment "duration 또는 instant"@ko .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 334-338: XBRL 표준 반영
efin:XBRLConcept a owl:Class ; 
  rdfs:label "XBRL Concept"@en .

efin:hasXbrlConcept a owl:ObjectProperty ; 
  rdfs:domain efin:MetricObservation ; 
  rdfs:range efin:XBRLConcept .

efin:hasQName a owl:DatatypeProperty ; 
  rdfs:domain efin:XBRLConcept ; 
  rdfs:range xsd:string .</code>
                </div>
            </div>

            <h3>2. 재사용 가능성</h3>
            <div class="highlight-box">
                <strong>FIBO-BE 통합 완료:</strong>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li>efin:Company가 fibo-be:LegalEntity의 하위 클래스</li>
                    <li>FIBO 프로퍼티와의 매핑 문서화 (hasLegalName, hasIdentifier)</li>
                    <li>표준 네임스페이스 사용: https://w3id.org/edgar-fin/2024#</li>
                    <li>온톨로지 import 선언: owl:imports를 통한 FIBO 통합</li>
                </ul>
            </div>

            <div class="highlight-box">
                <strong>스키마 파일에서의 실제 구현:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 21-24: FIBO-BE 통합
efin:Company a owl:Class ;
  rdfs:subClassOf fibo-be:LegalEntity ;
  rdfs:label "Company"@en ;
  rdfs:comment "법적 실체로서의 기업. FIBO-BE의 LegalEntity를 상속받아 표준 재무 온톨로지와의 상호 운용성을 확보함."@ko .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 9-18: 온톨로지 import 및 메타데이터
efin:Ontology a owl:Ontology ;
  rdfs:label "EFIN Financial Ontology"@en ;
  rdfs:comment "회사 수준의 재무 지표와 관측값을 위한 재무 보고 온톨로지..."@ko ;
  owl:versionInfo "1.0.0" ;
  dcterms:creator "EFIN Project Team" ;
  dcterms:created "2024-01-01"^^xsd:date ;
  dcterms:modified "2024-12-31"^^xsd:date ;
  dcterms:license <https://creativecommons.org/licenses/by/4.0/> ;
  dcterms:description "Financial ontology for SEC EDGAR XBRL data..."@en ;
  owl:imports <https://spec.edmcouncil.org/fibo/ontology/BE/> .</code>
                </div>
            </div>

            <h3>3. 확장 가능성</h3>
            <ul class="evaluation-points">
                <li><strong>새로운 메트릭 추가 용이:</strong> BaseMetric 또는 DerivedMetric 하위 클래스로 추가, 기존 구조 변경 없이 확장 가능</li>
                <li><strong>새로운 관계 추가 용이:</strong> ObjectProperty 추가로 새로운 관계 표현 가능</li>
                <li><strong>기존 구조 호환성:</strong> 확장 시 기존 구조와 호환됨</li>
            </ul>

            <div class="highlight-box">
                <strong>스키마 파일에서의 확장 가능성 예시:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 304-307: 새로운 DerivedMetric 추가 예시 (기존 구조 변경 없이)
efin:NOPAT a owl:Class ; 
  rdfs:subClassOf efin:DerivedMetric ; 
  rdfs:label "NOPAT"@en ;
  efin:hasFormulaNote "NOPAT = OperatingIncome * (1 − TaxRate); TaxRate ≈ IncomeTaxExpense / PreTaxIncome."@en .

efin:InvestedCapital a owl:Class ; 
  rdfs:subClassOf efin:DerivedMetric ; 
  rdfs:label "Invested Capital"@en ;
  efin:hasFormulaNote "≈ LongTermDebt + ShortTermDebt(or DebtCurrent) + Equity − CashAndCashEquivalents."@en .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 330-331: 새로운 DerivedRatio 추가 예시
efin:ROIC a owl:Class ; 
  rdfs:subClassOf efin:DerivedRatio ; 
  rdfs:label "ROIC"@en ;
  efin:hasFormulaNote "ROIC = NOPAT / InvestedCapital."@en .</code>
                </div>
            </div>

            <h3>4. 실용성</h3>
            <ul class="evaluation-points">
                <li><strong>실제 데이터 추출:</strong> SEC EDGAR API 연동, 자동화된 데이터 추출 파이프라인</li>
                <li><strong>쿼리 가능성:</strong> SPARQL 쿼리 예시 제공, 투자 분석 쿼리 문서화</li>
                <li><strong>벤치마크/랭킹 지원:</strong> 산업별/섹터별 비교 분석 지원, TopN 랭킹 데이터 제공</li>
                <li><strong>자동 변환:</strong> CSV → TTL 자동 변환 기능</li>
            </ul>

            <h3>5. 계층 구조를 통한 고차원 질의의 실현</h3>
            <div class="highlight-box" style="background: #f0f8ff; border-left: 4px solid #2c5aa0;">
                <strong style="color: #2c5aa0;">재무제표 metric 기반의 추상화 계층</strong>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>DerivedRatio, TopRanking, IndustryBenchmark, SectorBenchmark</strong> 같은 클래스들은 
                    재무제표의 기본 metric에 기반하여 만들어진 <strong>의미론적 추상화 계층</strong>입니다. 
                    이들은 단순한 데이터 저장소가 아니라, 그래프 질의를 통해 
                    <strong>일반적인 질의가 아닌 고차원적인 분석 질의</strong>를 가능하게 합니다.
                </p>

                <h4 style="color: #2c5aa0; margin-top: 20px;">1. DerivedRatio 계층을 통한 비율 지표 통합 분석</h4>
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 48-51
efin:DerivedRatio a owl:Class ;
  rdfs:subClassOf efin:DerivedMetric ;
  rdfs:label "DerivedRatio"@en ;
  rdfs:comment "비율 형태의 파생 메트릭 (예: ROE, DebtToEquity, EBITDA Margin)."@ko .

# 일반 질의: 각 비율을 개별적으로 조회해야 함
SELECT ?company ?roe ?roic ?grossMargin WHERE {
  ?obs1 efin:ofCompany ?company ; efin:observesMetric efin:ROE ; efin:hasNumericValue ?roe .
  ?obs2 efin:ofCompany ?company ; efin:observesMetric efin:ROIC ; efin:hasNumericValue ?roic .
  ?obs3 efin:ofCompany ?company ; efin:observesMetric efin:GrossMargin ; efin:hasNumericValue ?grossMargin .
}

# 고차원 질의: DerivedRatio 계층을 통해 모든 비율을 한 번에 조회
SELECT ?company ?ratioType ?value WHERE {
  ?obs efin:ofCompany ?company ;
       efin:observesMetric ?ratio ;
       efin:hasFiscalYear "2024"^^xsd:gYear ;
       efin:hasNumericValue ?value .
  ?ratio rdfs:subClassOf efin:DerivedRatio .  # 계층 구조 활용
  ?ratio rdfs:label ?ratioType .
}
ORDER BY ?company ?ratioType

# 장점: 새로운 DerivedRatio 클래스 추가 시 자동으로 질의에 포함됨
# → 확장 가능한 분석 프레임워크</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">2. TopRanking을 통한 포트폴리오 및 경쟁력 분석</h4>
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 65-67, 134-138
efin:TopRanking a owl:Class ;
  rdfs:label "TopRanking"@en ;
  rdfs:comment "특정 산업/섹터 내 메트릭별 상위 랭킹 (Top10, Top50, Top100)."@ko .

efin:hasRanking a owl:ObjectProperty ;
  rdfs:domain efin:Company ;
  rdfs:range efin:TopRanking ;
  rdfs:label "hasRanking"@en .

# 일반 질의: 각 메트릭별로 상위 기업을 개별 조회해야 함
# (복잡하고 비효율적)

# 고차원 질의: TopRanking 클래스를 통해 다양한 메트릭의 상위 기업을 통합 분석
SELECT ?company ?ticker ?metric ?rank ?value ?compositeScore ?rankingType WHERE {
  ?company efin:hasTicker ?ticker ;
           efin:hasRanking ?ranking .
  ?ranking a efin:TopRanking ;  # TopRanking 클래스 활용
           efin:forMetric ?metric ;
           efin:forFiscalYear "2024"^^xsd:gYear ;
           efin:hasRank ?rank ;
           efin:hasRankingValue ?value ;
           efin:hasRankingType ?rankingType ;
           efin:hasCompositeScore ?compositeScore .
  FILTER (?rank <= 10)
}
ORDER BY ?metric ?rank

# 활용: 포트폴리오 구성, 리스크 분산 분석, 경쟁력 평가 등 고차원 분석</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">3. IndustryBenchmark/SectorBenchmark를 통한 벤치마크 분석</h4>
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 57-63, 110-120
efin:IndustryBenchmark a owl:Class ;
  rdfs:label "IndustryBenchmark"@en ;
  rdfs:comment "특정 산업과 연도에 대한 벤치마크 통계값."@ko .

efin:forIndustry a owl:ObjectProperty ;
  rdfs:domain efin:IndustryBenchmark ;
  rdfs:range efin:Industry ;
  rdfs:label "forIndustry"@en .

# 일반 질의: 각 기업의 지표를 개별적으로 산업 평균과 비교
# (매우 복잡하고 시간 소모적)

# 고차원 질의: IndustryBenchmark 클래스를 통해 산업 전체 성과를 한 번에 평가
SELECT ?company ?ticker ?metric ?value ?industryAvg ?median ?percentile25 ?percentile75
       ((?value - ?industryAvg) / ?industryAvg AS ?deviationFromAvg)
       (IF(?value > ?percentile75, "상위권", 
           IF(?value < ?percentile25, "하위권", "중위권")) AS ?tier)
WHERE {
  ?company efin:hasTicker ?ticker ;
           efin:inIndustry ?industry .
  ?obs efin:ofCompany ?company ;
       efin:observesMetric ?metric ;
       efin:hasFiscalYear "2024"^^xsd:gYear ;
       efin:hasNumericValue ?value .
  ?benchmark a efin:IndustryBenchmark ;  # IndustryBenchmark 클래스 활용
             efin:forIndustry ?industry ;
             efin:forMetric ?metric ;
             efin:forFiscalYear "2024"^^xsd:gYear ;
             efin:hasAverageValue ?industryAvg ;
             efin:hasMedianValue ?median ;
             efin:hasPercentile25 ?percentile25 ;
             efin:hasPercentile75 ?percentile75 .
}
ORDER BY ?metric DESC(?deviationFromAvg)

# 활용: 경쟁력 분석, 벤치마킹, 성과 평가 등 고차원 분석</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">4. 복합 고차원 질의: 랭킹 + 벤치마크 통합 분석</h4>
                <div class="code-example">
<code># 가장 고차원적인 질의: 여러 추상화 계층을 동시에 활용
# 랭킹에 포함된 기업들의 벤치마크 대비 성과를 종합 분석
SELECT ?company ?ticker ?metric ?rank ?value ?industryAvg ?sectorAvg
       ((?value - ?industryAvg) / ?industryAvg AS ?industryDeviation)
       ((?value - ?sectorAvg) / ?sectorAvg AS ?sectorDeviation)
       ?compositeScore
WHERE {
  # TopRanking을 통한 랭킹 정보
  ?company efin:hasTicker ?ticker ;
           efin:hasRanking ?ranking .
  ?ranking a efin:TopRanking ;
           efin:forMetric ?metric ;
           efin:hasRank ?rank ;
           efin:hasRankingValue ?value ;
           efin:hasCompositeScore ?compositeScore .
  
  # IndustryBenchmark를 통한 산업 벤치마크
  ?company efin:inIndustry ?industry .
  ?indBenchmark a efin:IndustryBenchmark ;
                efin:forIndustry ?industry ;
                efin:forMetric ?metric ;
                efin:hasAverageValue ?industryAvg .
  
  # SectorBenchmark를 통한 섹터 벤치마크
  ?company efin:inSector ?sector .
  ?secBenchmark a efin:SectorBenchmark ;
                efin:forSector ?sector ;
                efin:forMetric ?metric ;
                efin:hasAverageValue ?sectorAvg .
  
  FILTER (?rank <= 10)
}
ORDER BY ?metric ?rank

# 결과: 랭킹, 산업 벤치마크, 섹터 벤치마크를 통합한 종합 분석
# → 투자 의사결정, 포트폴리오 최적화 등 최고차원 분석 가능</code>
                </div>

                <p style="margin-top: 15px; line-height: 1.8;">
                    <strong>고차원 질의가 가능한 핵심 원리:</strong>
                </p>
                <ul style="margin-top: 10px; padding-left: 20px; line-height: 1.8;">
                    <li><strong>계층 추상화:</strong> DerivedRatio 계층을 통해 "모든 비율 지표"를 개념적으로 그룹화</li>
                    <li><strong>관계 기반 추론:</strong> TopRanking의 forMetric, IndustryBenchmark의 forIndustry 관계를 통한 그래프 탐색</li>
                    <li><strong>의미론적 통합:</strong> 단순 데이터 조회가 아닌, 재무 분석 관점의 의미 있는 질의</li>
                    <li><strong>확장성:</strong> 새로운 클래스 추가 시 자동으로 고차원 질의에 포함</li>
                    <li><strong>복합 분석:</strong> 여러 추상화 계층을 동시에 활용한 종합 분석 가능</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Tab 4: OWL Principles -->
    <div id="tab-owl-principles" class="tab-content">
        <div class="evaluation-section">
            <h2>온톨로지 공학 원칙 준수</h2>
            <p><strong>평가 점수: 100/100 (완벽)</strong></p>
            <p>OWL 2 표준 준수, 추론 가능성, 제약 조건 활용, 모범 사례 준수를 평가합니다.</p>

            <h3>1. OWL 2 표준 준수</h3>
            <div class="diagram-container">
                <div class="controls">
                    <button class="control-btn" onclick="resetView('owl-principles')">리셋</button>
                    <button class="control-btn" id="owl-physics-btn" onclick="togglePhysics('owl-principles', this)">물리 시뮬레이션 (OFF)</button>
                </div>
                <div id="owl-principles-diagram" class="diagram"></div>
            </div>

            <div class="highlight-box">
                <strong>주요 OWL 2 구성 요소 활용:</strong>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li>owl:disjointWith - 상호 배타적 클래스</li>
                    <li>owl:equivalentClass - 등가 클래스 정의</li>
                    <li>owl:unionOf - 합집합 표현</li>
                    <li>owl:intersectionOf - 교집합 표현</li>
                    <li>owl:FunctionalProperty - 함수 속성</li>
                    <li>owl:TransitiveProperty - 전이적 속성</li>
                    <li>owl:AsymmetricProperty - 비대칭 속성</li>
                    <li>owl:hasKey - 키 제약</li>
                </ul>
            </div>

            <div class="highlight-box">
                <strong>스키마 파일에서의 실제 구현:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 424: Disjoint 제약
efin:BaseMetric owl:disjointWith efin:DerivedMetric .

# efin_schema.ttl 라인 427-429: EquivalentClass와 UnionOf
efin:Metric owl:equivalentClass [
  owl:unionOf (efin:BaseMetric efin:DerivedMetric)
] .

# efin_schema.ttl 라인 432-436: FunctionalProperty
efin:ofCompany a owl:FunctionalProperty .
efin:observesMetric a owl:FunctionalProperty .
efin:hasFiscalYear a owl:FunctionalProperty .
efin:hasPeriodEnd a owl:FunctionalProperty .
efin:hasNumericValue a owl:FunctionalProperty .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 439: TransitiveProperty
efin:computedFromObservation a owl:TransitiveProperty .

# efin_schema.ttl 라인 92: AsymmetricProperty
efin:inSectorOf a owl:ObjectProperty, owl:AsymmetricProperty ;
  rdfs:domain efin:Industry ;
  rdfs:range efin:Sector ;
  rdfs:label "inSectorOf"@en ;
  rdfs:comment "산업을 상위 섹터에 연결함. 비대칭 속성: Industry A가 Sector B에 속하면, Sector B는 Industry A에 속할 수 없음."@ko .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 520-524: Key 제약
efin:MetricObservation owl:hasKey (
  efin:ofCompany
  efin:observesMetric
  efin:hasFiscalYear
) .</code>
                </div>
            </div>

            <h3>2. 추론 가능성</h3>
            <p style="margin-bottom: 15px;">OWL 추론 엔진을 통한 자동 분류, 모순 감지, 관계 추론이 재무제표 분석에서 어떻게 활용되는지 설명합니다.</p>
            <table class="criteria-table">
                <thead>
                    <tr>
                        <th>추론 유형</th>
                        <th>설명</th>
                        <th>구현</th>
                        <th>달성 여부</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>자동 분류</strong></td>
                        <td>equivalentClass를 통한 자동 분류 가능</td>
                        <td>DurationObservation, InstantObservation</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                    <tr>
                        <td><strong>모순 감지</strong></td>
                        <td>disjointWith를 통한 모순 감지 가능</td>
                        <td>BaseMetric disjointWith DerivedMetric</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                    <tr>
                        <td><strong>완전 분류</strong></td>
                        <td>unionOf를 통한 완전 분류 추론 가능</td>
                        <td>Metric = BaseMetric ∪ DerivedMetric</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                    <tr>
                        <td><strong>관계 추론</strong></td>
                        <td>역 프로퍼티, 전이적 관계를 통한 자동 추론</td>
                        <td>inverseOf, TransitiveProperty</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                </tbody>
            </table>

            <div class="highlight-box">
                <strong>스키마 파일에서의 실제 구현:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 493-499: 자동 분류 (equivalentClass + intersectionOf)
efin:DurationObservation owl:equivalentClass [
  owl:intersectionOf (
    efin:MetricObservation
    [ owl:onProperty efin:hasPeriodType ;
      owl:hasValue "duration" ]
  )
] .

# efin_schema.ttl 라인 501-507: 자동 분류 (InstantObservation)
efin:InstantObservation owl:equivalentClass [
  owl:intersectionOf (
    efin:MetricObservation
    [ owl:onProperty efin:hasPeriodType ;
      owl:hasValue "instant" ]
  )
] .</code>
                </div>
            </div>

            <h3>2.1 재무제표 분석 관점에서의 정의 클래스 추론 활용</h3>
            <div class="highlight-box" style="background: #e7f3ff; border-left: 4px solid #2c5aa0;">
                <strong style="color: #2c5aa0;">정의 클래스를 통한 자동 추론의 실용적 활용</strong>
                <p style="margin-top: 10px;">DurationObservation과 InstantObservation은 단순한 분류가 아니라 재무제표 분석에서 핵심적인 역할을 합니다.</p>
                
                <p style="margin-top: 15px; line-height: 1.8;">
                    또한 <strong>DerivedRatio, TopRanking, IndustryBenchmark</strong> 같은 클래스들은 재무제표의 기본 metric들을 
                    <strong>의미론적으로 추상화</strong>한 것으로, 이를 통해 <strong>일반적인 질의가 아닌 고차원적인 질의</strong>를 수행할 수 있습니다.
                </p>
                
                <h4 style="color: #2c5aa0; margin-top: 20px;">1. 재무제표 유형별 자동 분류</h4>
                <div class="code-example">
<code># DurationObservation: 손익계산서, 현금흐름표 항목
# - 기간 동안의 누적값 (예: 2024년 1월 1일 ~ 12월 31일의 Revenue)
# - OWL Reasoner가 자동으로 periodType="duration"인 관측값을 분류

# InstantObservation: 재무상태표 항목
# - 특정 시점의 스냅샷 (예: 2024년 12월 31일 시점의 Assets)
# - OWL Reasoner가 자동으로 periodType="instant"인 관측값을 분류</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">2. 재무제표 분석 쿼리의 효율성</h4>
                <div class="code-example">
<code># 손익계산서 분석: DurationObservation만 조회
SELECT ?company ?metric ?value WHERE {
  ?obs a efin:DurationObservation ;  # 자동 분류된 클래스 활용
       efin:ofCompany ?company ;
       efin:observesMetric ?metric ;
       efin:hasFiscalYear "2024"^^xsd:gYear ;
       efin:hasNumericValue ?value .
  ?metric rdfs:subClassOf efin:BaseMetric .
}

# 재무상태표 분석: InstantObservation만 조회
SELECT ?company ?metric ?value WHERE {
  ?obs a efin:InstantObservation ;  # 자동 분류된 클래스 활용
       efin:ofCompany ?company ;
       efin:observesMetric ?metric ;
       efin:hasFiscalYear "2024"^^xsd:gYear ;
       efin:hasNumericValue ?value .
  ?metric rdfs:subClassOf efin:BaseMetric .
}</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">3. 재무 비율 계산의 정확성 보장</h4>
                <ul style="margin-top: 10px; padding-left: 20px; line-height: 1.8;">
                    <li><strong>기간형 비율:</strong> Revenue / Average(Assets) → DurationObservation과 InstantObservation의 평균값 사용</li>
                    <li><strong>시점형 비율:</strong> CurrentRatio = CurrentAssets / CurrentLiabilities → 둘 다 InstantObservation</li>
                    <li><strong>오류 방지:</strong> Disjoint 제약으로 Duration과 Instant를 혼용하는 오류 자동 감지</li>
                </ul>

                <div class="code-example">
<code># 실제 분석 예시: 자산회전율 계산
# AssetTurnover = Revenue (Duration) / Average(Assets_t, Assets_{t-1}) (Instant)
# 정의 클래스 추론을 통해 자동으로 올바른 기간 유형 확인 가능

SELECT ?company ?assetTurnover WHERE {
  ?obs efin:ofCompany ?company ;
       efin:observesMetric efin:AssetTurnover ;
       efin:hasFiscalYear "2024"^^xsd:gYear ;
       efin:hasNumericValue ?assetTurnover .
  # OWL Reasoner가 자동으로:
  # - Revenue 관측값이 DurationObservation인지 확인
  # - Assets 관측값이 InstantObservation인지 확인
  # - 혼용 시 모순 감지
}</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">4. 재무제표 비교 분석의 일관성</h4>
                <div class="code-example">
<code># 여러 회사의 손익계산서 비교
# DurationObservation 클래스를 통해 일관된 기간형 데이터만 추출
SELECT ?company ?revenue ?operatingIncome ?netIncome WHERE {
  ?obs1 a efin:DurationObservation ;  # 자동 분류 활용
        efin:ofCompany ?company ;
        efin:observesMetric efin:Revenue ;
        efin:hasFiscalYear "2024"^^xsd:gYear ;
        efin:hasNumericValue ?revenue .
  ?obs2 a efin:DurationObservation ;
        efin:ofCompany ?company ;
        efin:observesMetric efin:OperatingIncome ;
        efin:hasFiscalYear "2024"^^xsd:gYear ;
        efin:hasNumericValue ?operatingIncome .
  ?obs3 a efin:DurationObservation ;
        efin:ofCompany ?company ;
        efin:observesMetric efin:NetIncome ;
        efin:hasFiscalYear "2024"^^xsd:gYear ;
        efin:hasNumericValue ?netIncome .
}
ORDER BY DESC(?revenue)</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">5. 추론 엔진을 통한 자동 검증</h4>
                <ul style="margin-top: 10px; padding-left: 20px; line-height: 1.8;">
                    <li><strong>자동 분류:</strong> periodType 속성만으로 DurationObservation/InstantObservation 자동 분류</li>
                    <li><strong>모순 감지:</strong> 동일 관측값이 Duration과 Instant에 동시 속하는 경우 자동 감지</li>
                    <li><strong>데이터 품질:</strong> 재무제표 분석 전 데이터 일관성 자동 검증</li>
                </ul>

                <h4 style="color: #2c5aa0; margin-top: 20px;">6. 계층 구조를 통한 고차원 질의의 실현</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>DerivedRatio, TopRanking, IndustryBenchmark</strong> 같은 클래스들은 재무제표 metric에 기반하여 만들어진 
                    <strong>추상화 계층</strong>입니다. 이들은 단순한 데이터 저장소가 아니라, 그래프 질의를 통해 
                    <strong>고차원적인 분석 질의</strong>를 가능하게 합니다.
                </p>

                <div class="code-example">
<code># 스키마 파일에서의 실제 정의
# efin_schema.ttl 라인 48-51: DerivedRatio (파생 비율 계층)
efin:DerivedRatio a owl:Class ;
  rdfs:subClassOf efin:DerivedMetric ;
  rdfs:label "DerivedRatio"@en ;
  rdfs:comment "비율 형태의 파생 메트릭 (예: ROE, DebtToEquity, EBITDA Margin)."@ko .

# efin_schema.ttl 라인 65-67: TopRanking (랭킹 클래스)
efin:TopRanking a owl:Class ;
  rdfs:label "TopRanking"@en ;
  rdfs:comment "특정 산업/섹터 내 메트릭별 상위 랭킹 (Top10, Top50, Top100)."@ko .

# efin_schema.ttl 라인 57-59: IndustryBenchmark (산업 벤치마크)
efin:IndustryBenchmark a owl:Class ;
  rdfs:label "IndustryBenchmark"@en ;
  rdfs:comment "특정 산업과 연도에 대한 벤치마크 통계값."@ko .</code>
                </div>

                <div class="code-example">
<code># 고차원 질의 예시 1: DerivedRatio 계층을 통한 모든 비율 지표 통합 분석
# 일반 질의: 각 비율을 개별적으로 조회
SELECT ?company ?roe WHERE {
  ?obs efin:ofCompany ?company ;
       efin:observesMetric efin:ROE ;
       efin:hasNumericValue ?roe .
}

# 고차원 질의: DerivedRatio 계층을 통해 모든 비율을 한 번에 분석
SELECT ?company ?ratioType ?value WHERE {
  ?obs efin:ofCompany ?company ;
       efin:observesMetric ?ratio ;
       efin:hasFiscalYear "2024"^^xsd:gYear ;
       efin:hasNumericValue ?value .
  ?ratio rdfs:subClassOf efin:DerivedRatio ;  # 계층 구조 활용
         rdfs:label ?ratioType .
}
ORDER BY ?company ?ratioType</code>
                </div>

                <div class="code-example">
<code># 고차원 질의 예시 2: TopRanking을 통한 포트폴리오 구성
# 일반 질의: 각 메트릭별로 상위 기업을 개별 조회해야 함
# 고차원 질의: TopRanking 클래스를 통해 다양한 메트릭의 상위 기업을 통합 분석
SELECT ?company ?ticker ?metric ?rank ?value ?compositeScore WHERE {
  ?company efin:hasTicker ?ticker ;
           efin:hasRanking ?ranking .
  ?ranking a efin:TopRanking ;  # TopRanking 클래스 활용
           efin:forMetric ?metric ;
           efin:hasRank ?rank ;
           efin:hasRankingValue ?value ;
           efin:hasCompositeScore ?compositeScore .
  FILTER (?rank <= 10)
}
ORDER BY ?metric ?rank

# 결과: 다양한 메트릭(ROE, ROIC, Revenue 등)의 Top 10 기업을 한 번에 조회
# → 포트폴리오 구성, 리스크 분산 분석 등 고차원 분석 가능</code>
                </div>

                <div class="code-example">
<code># 고차원 질의 예시 3: IndustryBenchmark를 통한 산업 전체 성과 평가
# 일반 질의: 각 기업의 지표를 개별적으로 산업 평균과 비교
# 고차원 질의: IndustryBenchmark 클래스를 통해 산업 전체 성과를 한 번에 평가
SELECT ?company ?metric ?value ?industryAvg ?percentile25 ?percentile75
       ((?value - ?industryAvg) / ?industryAvg AS ?deviation)
       (IF(?value > ?percentile75, "상위권", 
           IF(?value < ?percentile25, "하위권", "중위권")) AS ?tier)
WHERE {
  ?company efin:inIndustry ?industry .
  ?obs efin:ofCompany ?company ;
       efin:observesMetric ?metric ;
       efin:hasFiscalYear "2024"^^xsd:gYear ;
       efin:hasNumericValue ?value .
  ?benchmark a efin:IndustryBenchmark ;  # IndustryBenchmark 클래스 활용
             efin:forIndustry ?industry ;
             efin:forMetric ?metric ;
             efin:hasAverageValue ?industryAvg ;
             efin:hasPercentile25 ?percentile25 ;
             efin:hasPercentile75 ?percentile75 .
}
ORDER BY ?metric DESC(?deviation)

# 결과: 산업 내 각 기업의 위치를 자동으로 분류 (상위권/중위권/하위권)
# → 경쟁력 분석, 벤치마킹 등 고차원 분석 가능</code>
                </div>

                <p style="margin-top: 15px; line-height: 1.8;">
                    이러한 고차원 질의가 가능한 이유:
                </p>
                <ul style="margin-top: 10px; padding-left: 20px; line-height: 1.8;">
                    <li><strong>계층 추상화:</strong> DerivedRatio 계층을 통해 "모든 비율 지표"를 개념적으로 그룹화하여 일괄 질의 가능</li>
                    <li><strong>관계 추론:</strong> TopRanking의 forMetric 관계를 통해 다양한 메트릭의 랭킹을 통합 분석</li>
                    <li><strong>그래프 탐색:</strong> IndustryBenchmark의 forIndustry 관계를 통해 산업 전체 성과를 한 번에 평가</li>
                    <li><strong>의미론적 질의:</strong> 단순 데이터 조회가 아닌, 재무 분석 관점의 의미 있는 질의 수행</li>
                    <li><strong>확장성:</strong> 새로운 DerivedRatio나 Benchmark 클래스를 추가하면 자동으로 고차원 질의에 포함됨</li>
                </ul>
            </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 424: 모순 감지 (disjointWith)
efin:BaseMetric owl:disjointWith efin:DerivedMetric .

# efin_schema.ttl 라인 509: 모순 감지 (DurationObservation과 InstantObservation)
efin:DurationObservation owl:disjointWith efin:InstantObservation .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 427-429: 완전 분류 (unionOf)
efin:Metric owl:equivalentClass [
  owl:unionOf (efin:BaseMetric efin:DerivedMetric)
] .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 442-446: 관계 추론 (역 프로퍼티)
efin:hasObservation a owl:ObjectProperty ;
  owl:inverseOf efin:ofCompany ;
  rdfs:domain efin:Company ;
  rdfs:range efin:MetricObservation ;
  rdfs:label "hasObservation"@en .

# efin_schema.ttl 라인 439: 관계 추론 (전이적 관계)
efin:computedFromObservation a owl:TransitiveProperty .</code>
                </div>
            </div>

            <h3>2.2 OWL 추론 엔진을 통한 의미론적 추론 시나리오</h3>
            <div class="highlight-box" style="background: #f0f8ff; border-left: 4px solid #2c5aa0;">
                <strong style="color: #2c5aa0;">의미론적 추론의 실용적 활용</strong>
                <p style="margin-top: 10px; line-height: 1.8;">
                    OWL 추론 엔진은 단순히 데이터를 저장하는 것이 아니라, <strong>명시적으로 표현되지 않은 지식을 자동으로 추론</strong>합니다. 
                    이를 통해 재무제표 분석에서 데이터 품질 검증, 관계 추적, 모순 감지 등이 자동화됩니다.
                </p>

                <h4 style="color: #2c5aa0; margin-top: 20px;">시나리오 1: equivalentClass를 통한 자동 분류</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>추론 메커니즘:</strong> periodType 속성 값만으로 DurationObservation/InstantObservation 클래스에 자동 분류됩니다.
                </p>
                
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 493-507
efin:DurationObservation owl:equivalentClass [
  owl:intersectionOf (
    efin:MetricObservation
    [ owl:onProperty efin:hasPeriodType ;
      owl:hasValue "duration" ]
  )
] .

efin:InstantObservation owl:equivalentClass [
  owl:intersectionOf (
    efin:MetricObservation
    [ owl:onProperty efin:hasPeriodType ;
      owl:hasValue "instant" ]
  )
] .

# 인스턴스 데이터 (명시적으로 DurationObservation으로 선언하지 않음)
efin:obs-0000320193-2024-Revenue-2024-12-31 a efin:MetricObservation ;
  efin:hasPeriodType "duration" ;
  efin:ofCompany efin:CIK0000320193 ;
  efin:observesMetric efin:Revenue .

# OWL 추론 엔진이 자동으로 추론:
# → efin:obs-0000320193-2024-Revenue-2024-12-31 a efin:DurationObservation</code>
                </div>

                <div class="code-example">
<code># 실용 예시 1: 손익계산서 항목 자동 분류
# periodType="duration"인 모든 관측값을 자동으로 DurationObservation으로 분류
SELECT ?obs ?company ?metric ?value WHERE {
  ?obs a efin:DurationObservation ;  # 추론 엔진이 자동 분류한 결과 활용
       efin:ofCompany ?company ;
       efin:observesMetric ?metric ;
       efin:hasNumericValue ?value .
  ?metric rdfs:subClassOf efin:BaseMetric .
}

# 실용 예시 2: 재무상태표 항목 자동 분류
# periodType="instant"인 모든 관측값을 자동으로 InstantObservation으로 분류
SELECT ?obs ?company ?metric ?value WHERE {
  ?obs a efin:InstantObservation ;  # 추론 엔진이 자동 분류한 결과 활용
       efin:ofCompany ?company ;
       efin:observesMetric ?metric ;
       efin:hasNumericValue ?value .
}

# 실용 예시 3: 기간 유형 혼용 오류 자동 감지
# OWL 추론 엔진이 DurationObservation과 InstantObservation이 disjoint임을 알고 있으므로,
# 동일 인스턴스가 두 클래스에 동시 속하는 경우 모순으로 감지</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">시나리오 2: disjointWith를 통한 모순 감지</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>추론 메커니즘:</strong> 상호 배타적인 클래스에 동시 속하는 인스턴스를 자동으로 감지하여 데이터 품질을 검증합니다.
                </p>
                
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 424, 509
efin:BaseMetric owl:disjointWith efin:DerivedMetric .
efin:DurationObservation owl:disjointWith efin:InstantObservation .

# 잘못된 데이터 예시 (모순 발생)
efin:SomeMetric a efin:BaseMetric, efin:DerivedMetric .  # 모순!
efin:SomeObs a efin:DurationObservation, efin:InstantObservation .  # 모순!

# OWL 추론 엔진이 자동으로 감지:
# → "Inconsistent: SomeMetric cannot be both BaseMetric and DerivedMetric"
# → "Inconsistent: SomeObs cannot be both DurationObservation and InstantObservation"</code>
                </div>

                <div class="code-example">
<code># 실용 예시 1: 메트릭 분류 모순 감지
# 동일 메트릭이 BaseMetric과 DerivedMetric에 동시 속하는 경우 자동 감지
# → 데이터 입력 오류 또는 스키마 설계 오류를 사전에 발견

# 실용 예시 2: 관측값 기간 유형 모순 감지
# 동일 관측값이 DurationObservation과 InstantObservation에 동시 속하는 경우 자동 감지
# → 재무제표 데이터의 일관성 검증

# 실용 예시 3: 데이터 품질 검증
# OWL 추론 엔진을 실행하여 모든 모순을 자동으로 발견
# → 재무제표 분석 전 데이터 무결성 보장</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">시나리오 3: unionOf를 통한 완전 분할</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>추론 메커니즘:</strong> Metric은 BaseMetric과 DerivedMetric의 합집합이므로, 모든 Metric 인스턴스는 둘 중 하나로 자동 분류됩니다.
                </p>
                
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 427-429
efin:Metric owl:equivalentClass [
  owl:unionOf (efin:BaseMetric efin:DerivedMetric)
] .

# 인스턴스 데이터
efin:Revenue a efin:Metric .  # 명시적으로 BaseMetric으로 선언하지 않음

# OWL 추론 엔진이 자동으로 추론:
# → efin:Revenue a efin:BaseMetric 또는 efin:DerivedMetric
# → efin:Revenue rdfs:subClassOf efin:BaseMetric 이므로
# → efin:Revenue a efin:BaseMetric 으로 자동 분류</code>
                </div>

                <div class="code-example">
<code># 실용 예시 1: 모든 Metric 인스턴스 자동 분류
# Metric으로만 선언된 인스턴스도 BaseMetric 또는 DerivedMetric으로 자동 분류
SELECT ?metric ?type WHERE {
  ?metric a efin:Metric .
  {
    ?metric a efin:BaseMetric .
    BIND("BaseMetric" AS ?type)
  } UNION {
    ?metric a efin:DerivedMetric .
    BIND("DerivedMetric" AS ?type)
  }
}

# 실용 예시 2: 누락된 분류 자동 감지
# Metric 인스턴스가 BaseMetric도 DerivedMetric도 아닌 경우 모순 감지
# → 스키마 설계 오류 또는 데이터 입력 오류 발견</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">시나리오 4: TransitiveProperty를 통한 전이 관계 추론</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>추론 메커니즘:</strong> computedFromObservation이 전이 속성이므로, 다단계 계산 체인을 자동으로 추론합니다.
                </p>
                
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 439
efin:computedFromObservation a owl:TransitiveProperty .

# 인스턴스 데이터
efin:obs-growth-2024 efin:computedFromObservation efin:obs-revenue-2024 .
efin:obs-revenue-2024 efin:computedFromObservation efin:obs-revenue-2023 .

# OWL 추론 엔진이 자동으로 추론:
# → efin:obs-growth-2024 efin:computedFromObservation efin:obs-revenue-2023
# (A → B, B → C 이면 A → C)</code>
                </div>

                <div class="code-example">
<code># 실용 예시 1: 파생 지표의 계산 근거 추적
# RevenueGrowthYoY → Revenue_2024 → Revenue_2023 전이 관계 자동 추론
SELECT ?derivedObs ?sourceObs WHERE {
  ?derivedObs efin:computedFromObservation+ ?sourceObs .  # + 는 전이 클로저
  ?derivedObs efin:observesMetric efin:RevenueGrowthYoY .
}

# 실용 예시 2: 다단계 계산 체인 자동 발견
# 직접 연결되지 않은 관측값 간의 관계도 자동으로 추론
SELECT ?obs1 ?obs2 WHERE {
  ?obs1 efin:computedFromObservation+ ?obs2 .
  # obs1이 obs2로부터 직접 또는 간접적으로 계산되었음을 자동 발견
}

# 실용 예시 3: 계산 의존성 그래프 구축
# 모든 계산 관계를 자동으로 추론하여 의존성 그래프 생성
# → 재무제표 분석 시 데이터 신뢰도 평가에 활용</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">시나리오 5: InverseProperty를 통한 양방향 관계 추론</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>추론 메커니즘:</strong> 역 속성을 통해 양방향 관계를 자동으로 추론하여 쿼리 효율성을 향상시킵니다.
                </p>
                
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 442-452
efin:hasObservation owl:inverseOf efin:ofCompany .
efin:observedBy owl:inverseOf efin:observesMetric .

# 인스턴스 데이터
efin:obs-001 efin:ofCompany efin:CIK0000320193 .
efin:obs-001 efin:observesMetric efin:Revenue .

# OWL 추론 엔진이 자동으로 추론:
# → efin:CIK0000320193 efin:hasObservation efin:obs-001
# → efin:Revenue efin:observedBy efin:obs-001</code>
                </div>

                <div class="code-example">
<code># 실용 예시 1: Company에서 MetricObservation 역방향 탐색
# ofCompany 관계만으로도 역방향 탐색 가능
SELECT ?company ?obs ?metric ?value WHERE {
  ?company efin:hasObservation ?obs .  # 역 속성 활용
  ?obs efin:observesMetric ?metric ;
       efin:hasNumericValue ?value .
}

# 실용 예시 2: Metric에서 MetricObservation 역방향 탐색
# observesMetric 관계만으로도 역방향 탐색 가능
SELECT ?metric ?obs ?company ?value WHERE {
  ?metric efin:observedBy ?obs .  # 역 속성 활용
  ?obs efin:ofCompany ?company ;
       efin:hasNumericValue ?value .
}

# 실용 예시 3: 양방향 쿼리 효율성
# 방향에 관계없이 효율적인 쿼리 작성 가능
# → 그래프 탐색 최적화 및 쿼리 성능 향상</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">시나리오 6: FunctionalProperty를 통한 유일성 보장</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>추론 메커니즘:</strong> 함수 속성은 각 인스턴스가 해당 속성에 대해 단일 값만 가질 수 있음을 보장합니다.
                </p>
                
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 432-436
efin:ofCompany a owl:FunctionalProperty .
efin:observesMetric a owl:FunctionalProperty .
efin:hasFiscalYear a owl:FunctionalProperty .
efin:hasNumericValue a owl:FunctionalProperty .

# 잘못된 데이터 예시 (모순 발생)
efin:obs-001 efin:ofCompany efin:CIK0000320193, efin:CIK0000796343 .  # 모순!
efin:obs-001 efin:hasNumericValue 1000000, 2000000 .  # 모순!

# OWL 추론 엔진이 자동으로 감지:
# → "Inconsistent: obs-001 cannot have multiple ofCompany values"
# → "Inconsistent: obs-001 cannot have multiple hasNumericValue values"</code>
                </div>

                <div class="code-example">
<code># 실용 예시 1: 데이터 일관성 검증
# 동일 관측값이 여러 회사에 속하는 경우 모순 감지
# → 데이터 입력 오류 자동 발견

# 실용 예시 2: 메트릭 관측 일관성 검증
# 동일 관측값이 여러 메트릭을 관측하는 경우 모순 감지
# → 재무제표 데이터의 무결성 보장

# 실용 예시 3: 수치값 유일성 보장
# 동일 관측값이 여러 수치값을 가지는 경우 모순 감지
# → 데이터 품질 검증 및 오류 방지</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">시나리오 7: AsymmetricProperty를 통한 비대칭 관계</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>추론 메커니즘:</strong> 비대칭 속성은 관계의 방향성을 보장하여 잘못된 역방향 관계를 자동으로 거부합니다.
                </p>
                
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 92
efin:inSectorOf a owl:ObjectProperty, owl:AsymmetricProperty ;
  rdfs:domain efin:Industry ;
  rdfs:range efin:Sector .

# 올바른 관계
efin:IndustryServicesPrepackagedSoftware efin:inSectorOf efin:SectorInformationTechnology .

# 잘못된 역방향 관계 (자동으로 거부됨)
efin:SectorInformationTechnology efin:inSectorOf efin:IndustryServicesPrepackagedSoftware .  # 모순!

# OWL 추론 엔진이 자동으로 감지:
# → "Inconsistent: Sector cannot be inSectorOf Industry (asymmetric violation)"</code>
                </div>

                <div class="code-example">
<code># 실용 예시 1: Industry → Sector 관계의 방향성 보장
# 역방향 관계가 자동으로 거부되어 데이터 일관성 보장
SELECT ?industry ?sector WHERE {
  ?industry efin:inSectorOf ?sector .
  # Sector → Industry 역방향 관계는 자동으로 거부됨
}

# 실용 예시 2: 계층 구조의 정확성 보장
# Industry가 Sector에 속하는 관계만 허용
# → 재무제표 분석 시 산업 분류의 정확성 보장</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">시나리오 8: hasKey를 통한 고유성 제약</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    <strong>추론 메커니즘:</strong> 키 제약을 통해 동일한 (회사, 메트릭, 회계연도) 조합의 중복 관측값을 자동으로 감지합니다.
                </p>
                
                <div class="code-example">
<code># 스키마 정의: efin_schema.ttl 라인 520-524
efin:MetricObservation owl:hasKey (
  efin:ofCompany
  efin:observesMetric
  efin:hasFiscalYear
) .

# 중복 데이터 예시 (모순 발생)
efin:obs-001 efin:ofCompany efin:CIK0000320193 ;
             efin:observesMetric efin:Revenue ;
             efin:hasFiscalYear "2024"^^xsd:gYear ;
             efin:hasNumericValue 1000000 .

efin:obs-002 efin:ofCompany efin:CIK0000320193 ;
             efin:observesMetric efin:Revenue ;
             efin:hasFiscalYear "2024"^^xsd:gYear ;
             efin:hasNumericValue 2000000 .  # 모순! (동일 키 조합)

# OWL 추론 엔진이 자동으로 감지:
# → "Inconsistent: obs-001 and obs-002 have the same key values"
# → "Key constraint violation: (CIK0000320193, Revenue, 2024) must be unique"</code>
                </div>

                <div class="code-example">
<code># 실용 예시 1: 중복 관측값 자동 감지
# 동일 (회사, 메트릭, 연도) 조합의 중복 데이터 자동 발견
# → 데이터 입력 오류 또는 데이터 소스 중복 발견

# 실용 예시 2: 데이터 정합성 검증
# 키 제약 위반을 자동으로 감지하여 데이터 무결성 보장
# → 재무제표 분석 전 데이터 품질 검증

# 실용 예시 3: 데이터베이스 정규화 보장
# 키 제약을 통해 정규화된 데이터 구조 보장
# → 데이터 일관성 및 분석 정확성 향상</code>
                </div>

                <h4 style="color: #2c5aa0; margin-top: 20px;">추론 시나리오 통합 활용</h4>
                <p style="margin-top: 10px; line-height: 1.8;">
                    실제 재무제표 분석에서는 여러 추론 메커니즘이 동시에 작동하여 종합적인 데이터 품질 검증과 의미론적 분석을 수행합니다.
                </p>

                <div class="code-example">
<code># 통합 시나리오: 재무제표 데이터 품질 종합 검증
# 1. equivalentClass: periodType 기반 자동 분류
# 2. disjointWith: BaseMetric/DerivedMetric 모순 감지
# 3. FunctionalProperty: 수치값 유일성 보장
# 4. hasKey: 중복 관측값 감지

# OWL 추론 엔진 실행 시 자동으로 수행:
# → 모든 관측값의 기간 유형 자동 분류
# → 모든 메트릭의 분류 모순 감지
# → 모든 관측값의 속성 유일성 검증
# → 모든 관측값의 키 고유성 검증

# 결과: 재무제표 분석 전 데이터 무결성 보장
# → 신뢰할 수 있는 재무 분석 결과 도출</code>
                </div>
            </div>

            <h3>3. 제약 조건 활용</h3>
            <table class="criteria-table">
                <thead>
                    <tr>
                        <th>제약 유형</th>
                        <th>설명</th>
                        <th>예시</th>
                        <th>달성 여부</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>카디널리티 제약</strong></td>
                        <td>minCardinality를 통한 필수 속성 정의</td>
                        <td>MetricObservation의 ofCompany, observesMetric 등</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                    <tr>
                        <td><strong>함수 속성 제약</strong></td>
                        <td>FunctionalProperty를 통한 단일 값 제약</td>
                        <td>ofCompany, observesMetric, hasNumericValue</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                    <tr>
                        <td><strong>키 제약</strong></td>
                        <td>owl:hasKey를 통한 고유성 제약</td>
                        <td>(ofCompany, observesMetric, hasFiscalYear)</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                    <tr>
                        <td><strong>값 제약</strong></td>
                        <td>hasValue를 통한 특정 값 제약</td>
                        <td>DurationObservation, InstantObservation</td>
                        <td><span class="status-badge achieved">✅</span></td>
                    </tr>
                </tbody>
            </table>

            <div class="highlight-box">
                <strong>스키마 파일에서의 실제 구현:</strong>
                <div class="code-example">
<code># efin_schema.ttl 라인 455-478: 카디널리티 제약 (필수 속성)
efin:MetricObservation rdfs:subClassOf [
  owl:onProperty efin:ofCompany ;
  owl:minCardinality 1
] .

efin:MetricObservation rdfs:subClassOf [
  owl:onProperty efin:observesMetric ;
  owl:minCardinality 1
] .

efin:MetricObservation rdfs:subClassOf [
  owl:onProperty efin:hasFiscalYear ;
  owl:minCardinality 1
] .

efin:MetricObservation rdfs:subClassOf [
  owl:onProperty efin:hasNumericValue ;
  owl:minCardinality 1
] .

efin:MetricObservation rdfs:subClassOf [
  owl:onProperty efin:hasPeriodType ;
  owl:minCardinality 1
] .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 432-436: 함수 속성 (단일 값 제약)
efin:ofCompany a owl:FunctionalProperty .
efin:observesMetric a owl:FunctionalProperty .
efin:hasFiscalYear a owl:FunctionalProperty .
efin:hasPeriodEnd a owl:FunctionalProperty .
efin:hasNumericValue a owl:FunctionalProperty .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 520-524: 키 제약 (고유성)
efin:MetricObservation owl:hasKey (
  efin:ofCompany
  efin:observesMetric
  efin:hasFiscalYear
) .</code>
                </div>

                <div class="code-example">
<code># efin_schema.ttl 라인 493-499: 값 제약 (hasValue)
efin:DurationObservation owl:equivalentClass [
  owl:intersectionOf (
    efin:MetricObservation
    [ owl:onProperty efin:hasPeriodType ;
      owl:hasValue "duration" ]
  )
] .</code>
                </div>
            </div>

            <h3>4. 모범 사례 준수</h3>
            <ul class="evaluation-points">
                <li><strong>Observation Pattern:</strong> MetricObservation 클래스로 관측값 모델링</li>
                <li><strong>Naming Conventions:</strong> 클래스 PascalCase, 프로퍼티 camelCase</li>
                <li><strong>Documentation:</strong> 모든 클래스/프로퍼티에 label 및 comment 제공</li>
                <li><strong>Modularity:</strong> 스키마와 인스턴스 분리</li>
                <li><strong>온톨로지 메타데이터:</strong> 버전, 생성자, 라이선스 정보 제공</li>
                <li><strong>표준 온톨로지 통합:</strong> FIBO import 및 통합</li>
                <li><strong>프로퍼티 특성 정의:</strong> FunctionalProperty, TransitiveProperty, AsymmetricProperty 활용</li>
                <li><strong>역 프로퍼티 정의:</strong> 양방향 관계를 위한 역 프로퍼티 제공</li>
            </ul>
        </div>
    </div>

    <div class="info-panel" id="info-panel">
        <button class="close-btn" onclick="closeInfo()">×</button>
        <h3 id="info-title">정보</h3>
        <div class="info-content" id="info-content"></div>
    </div>

    <script>
        // ==================== Global Variables ====================
        let systematicityNetwork, hierarchyNetwork, appropriatenessNetwork, owlPrinciplesNetwork;
        let systematicityPhysics = false, hierarchyPhysics = false, appropriatenessPhysics = false, owlPrinciplesPhysics = false;

        // ==================== Tab Switching ====================
        function switchTab(tabName, btnElement) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            document.getElementById(`tab-${tabName}`).classList.add('active');
            if (btnElement) {
                btnElement.classList.add('active');
            }

            closeInfo();

            // Initialize diagram if not already initialized
            if (tabName === 'systematicity' && !systematicityNetwork) {
                initSystematicityDiagram();
            } else if (tabName === 'hierarchy' && !hierarchyNetwork) {
                initHierarchyDiagram();
            } else if (tabName === 'appropriateness' && !appropriatenessNetwork) {
                initAppropriatenessDiagram();
            } else if (tabName === 'owl-principles' && !owlPrinciplesNetwork) {
                initOWLPrinciplesDiagram();
            }
        }

        function closeInfo() {
            document.getElementById('info-panel').classList.remove('show');
        }

        // ==================== Systematicity Diagram ====================
        function initSystematicityDiagram() {
            const nodes = [
                { id: 'Metric', label: 'Metric', group: 'core', level: 0, 
                  title: '추상 메트릭 개념 (기본 또는 파생)' },
                { id: 'BaseMetric', label: 'BaseMetric', group: 'subclass', level: 1,
                  title: 'XBRL에서 직접 추출된 기초 지표 (24개 구체 클래스)' },
                { id: 'DerivedMetric', label: 'DerivedMetric', group: 'subclass', level: 1,
                  title: '계산된 파생 지표' },
                { id: 'DerivedRatio', label: 'DerivedRatio', group: 'subclass', level: 2,
                  title: '비율 형태의 파생 메트릭 (17개 구체 클래스)' },
                { id: 'Revenue', label: 'Revenue', group: 'instance', level: 2,
                  title: 'BaseMetric의 구체 클래스 예시' },
                { id: 'RevenueGrowthYoY', label: 'RevenueGrowthYoY', group: 'instance', level: 3,
                  title: 'DerivedRatio의 구체 클래스 예시' },
                { id: 'MetricObservation', label: 'MetricObservation', group: 'core', level: 0,
                  title: '특정 기업, 지표, 기간에 대한 관측값' },
                { id: 'DurationObservation', label: 'Duration\nObservation', group: 'defined', level: 1,
                  title: '정의 클래스: periodType="duration"인 MetricObservation' },
                { id: 'InstantObservation', label: 'Instant\nObservation', group: 'defined', level: 1,
                  title: '정의 클래스: periodType="instant"인 MetricObservation' },
                { id: 'Company', label: 'Company', group: 'reused', level: 0,
                  title: 'FIBO-BE의 LegalEntity 상속' },
            ];

            const edges = [
                { from: 'Metric', to: 'BaseMetric', label: 'subClassOf', dashes: true },
                { from: 'Metric', to: 'DerivedMetric', label: 'subClassOf', dashes: true },
                { from: 'DerivedMetric', to: 'DerivedRatio', label: 'subClassOf', dashes: true },
                { from: 'BaseMetric', to: 'Revenue', label: 'subClassOf', dashes: true },
                { from: 'DerivedRatio', to: 'RevenueGrowthYoY', label: 'subClassOf', dashes: true },
                { from: 'MetricObservation', to: 'DurationObservation', label: 'equivalentClass', color: '#9b59b6', dashes: [5,5] },
                { from: 'MetricObservation', to: 'InstantObservation', label: 'equivalentClass', color: '#9b59b6', dashes: [5,5] },
                { from: 'BaseMetric', to: 'DerivedMetric', label: 'disjointWith', color: '#d9534f', dashes: [10,5] },
                { from: 'DurationObservation', to: 'InstantObservation', label: 'disjointWith', color: '#d9534f', dashes: [10,5] },
            ];

            const container = document.getElementById('systematicity-diagram');
            const data = { nodes: nodes, edges: edges };
            const options = {
                nodes: {
                    shape: 'box',
                    margin: 10,
                    widthConstraint: { maximum: 150 },
                    font: { size: 13, face: 'Segoe UI', color: '#ffffff', bold: true },
                    borderWidth: 3,
                    shadow: true
                },
                edges: {
                    width: 2,
                    arrows: { to: { enabled: true, scaleFactor: 0.8 } },
                    font: { size: 11, align: 'middle', background: 'white' },
                    smooth: { type: 'cubicBezier', forceDirection: 'vertical', roundness: 0.4 }
                },
                groups: {
                    core: { color: { background: '#2c5aa0', border: '#1e3a6e' } },
                    subclass: { color: { background: '#5bc0de', border: '#46b8da' } },
                    defined: { color: { background: '#5cb85c', border: '#449d44' } },
                    reused: { color: { background: '#f0ad4e', border: '#ec971f' } },
                    instance: { color: { background: '#d1ecf1', border: '#0c5460' } }
                },
                layout: {
                    hierarchical: { enabled: true, direction: 'UD', sortMethod: 'directed', levelSeparation: 150, nodeSpacing: 100 }
                },
                physics: { enabled: false },
                interaction: { hover: true, navigationButtons: true, keyboard: true, zoomView: true }
            };

            systematicityNetwork = new vis.Network(container, data, options);

            systematicityNetwork.on('click', function(params) {
                if (params.nodes.length > 0) {
                    showNodeInfo(params.nodes[0], nodes);
                }
            });
        }

        // ==================== Hierarchy Diagram ====================
        function initHierarchyDiagram() {
            const nodes = [
                { id: 'owl:Thing', label: 'owl:Thing', group: 'root', level: 0 },
                { id: 'Metric', label: 'Metric', group: 'abstract', level: 1 },
                { id: 'BaseMetric', label: 'BaseMetric', group: 'concrete', level: 2 },
                { id: 'DerivedMetric', label: 'DerivedMetric', group: 'concrete', level: 2 },
                { id: 'DerivedRatio', label: 'DerivedRatio', group: 'concrete', level: 3 },
                { id: 'Revenue', label: 'Revenue', group: 'instance', level: 3 },
                { id: 'RevenueGrowthYoY', label: 'RevenueGrowthYoY', group: 'instance', level: 4 },
                { id: 'MetricObservation', label: 'MetricObservation', group: 'abstract', level: 1 },
                { id: 'DurationObservation', label: 'Duration\nObservation', group: 'defined', level: 2 },
                { id: 'InstantObservation', label: 'Instant\nObservation', group: 'defined', level: 2 },
            ];

            const edges = [
                { from: 'owl:Thing', to: 'Metric', label: 'subClassOf', dashes: true },
                { from: 'owl:Thing', to: 'MetricObservation', label: 'subClassOf', dashes: true },
                { from: 'Metric', to: 'BaseMetric', label: 'subClassOf', dashes: true },
                { from: 'Metric', to: 'DerivedMetric', label: 'subClassOf', dashes: true },
                { from: 'DerivedMetric', to: 'DerivedRatio', label: 'subClassOf', dashes: true },
                { from: 'BaseMetric', to: 'Revenue', label: 'subClassOf', dashes: true },
                { from: 'DerivedRatio', to: 'RevenueGrowthYoY', label: 'subClassOf', dashes: true },
                { from: 'MetricObservation', to: 'DurationObservation', label: 'equivalentClass', color: '#9b59b6', dashes: [5,5] },
                { from: 'MetricObservation', to: 'InstantObservation', label: 'equivalentClass', color: '#9b59b6', dashes: [5,5] },
            ];

            const container = document.getElementById('hierarchy-diagram');
            const data = { nodes: nodes, edges: edges };
            const options = {
                nodes: {
                    shape: 'box',
                    margin: 10,
                    widthConstraint: { maximum: 150 },
                    font: { size: 13, face: 'Segoe UI', color: '#ffffff', bold: true },
                    borderWidth: 3,
                    shadow: true
                },
                edges: {
                    width: 2,
                    arrows: { to: { enabled: true, scaleFactor: 0.8 } },
                    font: { size: 11, align: 'middle', background: 'white' },
                    smooth: { type: 'cubicBezier', forceDirection: 'vertical', roundness: 0.4 }
                },
                groups: {
                    root: { color: { background: '#6c757d', border: '#495057' } },
                    abstract: { color: { background: '#2c5aa0', border: '#1e3a6e' } },
                    concrete: { color: { background: '#5bc0de', border: '#46b8da' } },
                    defined: { color: { background: '#5cb85c', border: '#449d44' } },
                    instance: { color: { background: '#d1ecf1', border: '#0c5460' } }
                },
                layout: {
                    hierarchical: { enabled: true, direction: 'UD', sortMethod: 'directed', levelSeparation: 120, nodeSpacing: 80 }
                },
                physics: { enabled: false },
                interaction: { hover: true, navigationButtons: true, keyboard: true, zoomView: true }
            };

            hierarchyNetwork = new vis.Network(container, data, options);

            hierarchyNetwork.on('click', function(params) {
                if (params.nodes.length > 0) {
                    showNodeInfo(params.nodes[0], nodes);
                }
            });
        }

        // ==================== Appropriateness Diagram ====================
        function initAppropriatenessDiagram() {
            const nodes = [
                { id: 'Company', label: 'Company', group: 'reused', level: 0,
                  title: 'FIBO-BE의 LegalEntity 상속' },
                { id: 'fibo-be:LegalEntity', label: 'fibo-be:\nLegalEntity', group: 'external', level: 1,
                  title: 'FIBO 표준 온톨로지 재사용' },
                { id: 'Metric', label: 'Metric', group: 'core', level: 0 },
                { id: 'BaseMetric', label: 'BaseMetric', group: 'base', level: 1 },
                { id: 'DerivedMetric', label: 'DerivedMetric', group: 'derived', level: 1 },
                { id: 'Revenue', label: 'Revenue', group: 'instance', level: 2 },
                { id: 'ROE', label: 'ROE', group: 'instance', level: 2 },
                { id: 'MetricObservation', label: 'MetricObservation', group: 'core', level: 0 },
                { id: 'Sector', label: 'Sector', group: 'core', level: 0 },
                { id: 'Industry', label: 'Industry', group: 'core', level: 0 },
            ];

            const edges = [
                { from: 'Company', to: 'fibo-be:LegalEntity', label: 'subClassOf', color: '#f0ad4e', dashes: true },
                { from: 'Metric', to: 'BaseMetric', label: 'subClassOf', dashes: true },
                { from: 'Metric', to: 'DerivedMetric', label: 'subClassOf', dashes: true },
                { from: 'BaseMetric', to: 'Revenue', label: 'subClassOf', dashes: true },
                { from: 'DerivedMetric', to: 'ROE', label: 'subClassOf', dashes: true },
                { from: 'MetricObservation', to: 'Company', label: 'ofCompany', color: '#5cb85c' },
                { from: 'MetricObservation', to: 'Metric', label: 'observesMetric', color: '#5cb85c' },
                { from: 'Company', to: 'Sector', label: 'inSector', color: '#5cb85c' },
                { from: 'Company', to: 'Industry', label: 'inIndustry', color: '#5cb85c' },
            ];

            const container = document.getElementById('appropriateness-diagram');
            const data = { nodes: nodes, edges: edges };
            const options = {
                nodes: {
                    shape: 'box',
                    margin: 10,
                    widthConstraint: { maximum: 150 },
                    font: { size: 13, face: 'Segoe UI', color: '#ffffff', bold: true },
                    borderWidth: 3,
                    shadow: true
                },
                edges: {
                    width: 2,
                    arrows: { to: { enabled: true, scaleFactor: 0.8 } },
                    font: { size: 11, align: 'middle', background: 'white' },
                    smooth: { type: 'cubicBezier', roundness: 0.4 }
                },
                groups: {
                    reused: { color: { background: '#f0ad4e', border: '#ec971f' } },
                    external: { color: { background: '#9b59b6', border: '#7d3c98' } },
                    core: { color: { background: '#2c5aa0', border: '#1e3a6e' } },
                    base: { color: { background: '#5bc0de', border: '#46b8da' } },
                    derived: { color: { background: '#17a2b8', border: '#138496' } },
                    instance: { color: { background: '#d1ecf1', border: '#0c5460' } }
                },
                layout: {
                    hierarchical: { enabled: true, direction: 'LR', sortMethod: 'directed', levelSeparation: 200, nodeSpacing: 120 }
                },
                physics: { enabled: false },
                interaction: { hover: true, navigationButtons: true, keyboard: true, zoomView: true }
            };

            appropriatenessNetwork = new vis.Network(container, data, options);

            appropriatenessNetwork.on('click', function(params) {
                if (params.nodes.length > 0) {
                    showNodeInfo(params.nodes[0], nodes);
                }
            });
        }

        // ==================== OWL Principles Diagram ====================
        function initOWLPrinciplesDiagram() {
            const nodes = [
                { id: 'MetricObservation', label: 'MetricObservation', group: 'core', level: 0 },
                { id: 'DurationObservation', label: 'Duration\nObservation', group: 'defined', level: 1 },
                { id: 'InstantObservation', label: 'Instant\nObservation', group: 'defined', level: 1 },
                { id: 'Metric', label: 'Metric', group: 'core', level: 0 },
                { id: 'BaseMetric', label: 'BaseMetric', group: 'subclass', level: 1 },
                { id: 'DerivedMetric', label: 'DerivedMetric', group: 'subclass', level: 1 },
                { id: 'Company', label: 'Company', group: 'core', level: 0 },
                { id: 'ofCompany', label: 'ofCompany\n(Functional)', group: 'property', level: 1 },
                { id: 'observesMetric', label: 'observesMetric\n(Functional)', group: 'property', level: 1 },
                { id: 'computedFromObservation', label: 'computedFromObservation\n(Transitive)', group: 'property', level: 1 },
                { id: 'hasKey', label: 'hasKey\n(ofCompany, observesMetric,\nhasFiscalYear)', group: 'constraint', level: 1 },
            ];

            const edges = [
                { from: 'MetricObservation', to: 'DurationObservation', label: 'equivalentClass', color: '#9b59b6', dashes: [5,5] },
                { from: 'MetricObservation', to: 'InstantObservation', label: 'equivalentClass', color: '#9b59b6', dashes: [5,5] },
                { from: 'Metric', to: 'BaseMetric', label: 'subClassOf', dashes: true },
                { from: 'Metric', to: 'DerivedMetric', label: 'subClassOf', dashes: true },
                { from: 'BaseMetric', to: 'DerivedMetric', label: 'disjointWith', color: '#d9534f', dashes: [10,5] },
                { from: 'DurationObservation', to: 'InstantObservation', label: 'disjointWith', color: '#d9534f', dashes: [10,5] },
                { from: 'MetricObservation', to: 'ofCompany', label: 'hasProperty', color: '#5cb85c' },
                { from: 'MetricObservation', to: 'observesMetric', label: 'hasProperty', color: '#5cb85c' },
                { from: 'MetricObservation', to: 'computedFromObservation', label: 'hasProperty', color: '#5cb85c' },
                { from: 'MetricObservation', to: 'hasKey', label: 'hasConstraint', color: '#f0ad4e' },
                { from: 'ofCompany', to: 'Company', label: 'range', color: '#17a2b8', dashes: [3,3] },
            ];

            const container = document.getElementById('owl-principles-diagram');
            const data = { nodes: nodes, edges: edges };
            const options = {
                nodes: {
                    shape: 'box',
                    margin: 10,
                    widthConstraint: { maximum: 180 },
                    font: { size: 12, face: 'Segoe UI', color: '#ffffff', bold: true },
                    borderWidth: 3,
                    shadow: true
                },
                edges: {
                    width: 2,
                    arrows: { to: { enabled: true, scaleFactor: 0.8 } },
                    font: { size: 10, align: 'middle', background: 'white' },
                    smooth: { type: 'cubicBezier', roundness: 0.4 }
                },
                groups: {
                    core: { color: { background: '#2c5aa0', border: '#1e3a6e' } },
                    defined: { color: { background: '#5cb85c', border: '#449d44' } },
                    subclass: { color: { background: '#5bc0de', border: '#46b8da' } },
                    property: { color: { background: '#17a2b8', border: '#138496' } },
                    constraint: { color: { background: '#f0ad4e', border: '#ec971f' } }
                },
                layout: {
                    hierarchical: { enabled: true, direction: 'UD', sortMethod: 'directed', levelSeparation: 150, nodeSpacing: 100 }
                },
                physics: { enabled: false },
                interaction: { hover: true, navigationButtons: true, keyboard: true, zoomView: true }
            };

            owlPrinciplesNetwork = new vis.Network(container, data, options);

            owlPrinciplesNetwork.on('click', function(params) {
                if (params.nodes.length > 0) {
                    showNodeInfo(params.nodes[0], nodes);
                }
            });
        }

        // ==================== Helper Functions ====================
        function showNodeInfo(nodeId, nodes) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            const panel = document.getElementById('info-panel');
            const title = document.getElementById('info-title');
            const content = document.getElementById('info-content');

            title.textContent = node.label.replace(/\n/g, ' ');
            content.innerHTML = `<p><strong>ID:</strong> ${node.id}</p>
                                <p><strong>그룹:</strong> ${node.group || 'N/A'}</p>
                                <p><strong>레벨:</strong> ${node.level !== undefined ? node.level : 'N/A'}</p>
                                ${node.title ? `<p><strong>설명:</strong> ${node.title}</p>` : ''}`;
            panel.classList.add('show');
        }

        function resetView(tab) {
            let network;
            if (tab === 'systematicity' && systematicityNetwork) {
                network = systematicityNetwork;
            } else if (tab === 'hierarchy' && hierarchyNetwork) {
                network = hierarchyNetwork;
            } else if (tab === 'appropriateness' && appropriatenessNetwork) {
                network = appropriatenessNetwork;
            } else if (tab === 'owl-principles' && owlPrinciplesNetwork) {
                network = owlPrinciplesNetwork;
            }

            if (network) {
                network.fit({
                    animation: { duration: 1000, easingFunction: 'easeInOutQuad' }
                });
                closeInfo();
            }
        }

        function togglePhysics(tab, btnElement) {
            let network, physicsEnabled;
            if (tab === 'systematicity') {
                network = systematicityNetwork;
                physicsEnabled = systematicityPhysics;
                systematicityPhysics = !systematicityPhysics;
            } else if (tab === 'hierarchy') {
                network = hierarchyNetwork;
                physicsEnabled = hierarchyPhysics;
                hierarchyPhysics = !hierarchyPhysics;
            } else if (tab === 'appropriateness') {
                network = appropriatenessNetwork;
                physicsEnabled = appropriatenessPhysics;
                appropriatenessPhysics = !appropriatenessPhysics;
            } else if (tab === 'owl-principles') {
                network = owlPrinciplesNetwork;
                physicsEnabled = owlPrinciplesPhysics;
                owlPrinciplesPhysics = !owlPrinciplesPhysics;
            }

            if (network) {
                network.setOptions({ physics: { enabled: !physicsEnabled } });
                if (!physicsEnabled) {
                    btnElement.classList.add('active');
                    btnElement.textContent = '물리 시뮬레이션 (ON)';
                } else {
                    btnElement.classList.remove('active');
                    btnElement.textContent = '물리 시뮬레이션 (OFF)';
                }
            }
        }

        // ==================== Initialize ====================
        window.addEventListener('load', function() {
            initSystematicityDiagram();
        });
    </script>
</body>
</html>

